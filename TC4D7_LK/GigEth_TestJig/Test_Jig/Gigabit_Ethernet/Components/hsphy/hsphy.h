/**
 * \file hsphy.h
 * \brief Functions to interface to the HSPH
 *
 * \version V0.1.0
 * \copyright Copyright (c) 2019-2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*******************************************************************************
**                             Author(s) Identity                             **
********************************************************************************
** Initials     Name                                                          **
** ---------------------------------------------------------------------------**
** RS           Ronny Schulze                                                 **
** DM           Daniel Mysliwitz                                              **
*******************************************************************************/

/*******************************************************************************
**                          Revision Control History                          **
********************************************************************************
** V0.1.0: 2021-11-16, DM:   Initial version                                  **
*******************************************************************************/

#ifndef IFX_HSPHY_H
#define IFX_HSPHY_H 1

#include "IfxHsphy.h"
#include "IfxHsphy_hsphy.h"


/**********************************************************************************************************************
 * MACROS
 *********************************************************************************************************************/
#define HSPHY_NUMBER_OF_PORTS (2u)

#define HSPHY_PORT0 (0u)
#define HSPHY_PORT1 (1u)

/**
 * HSPHY ETH port control
 */
typedef union HSPHY_ETH_PORT_CTRL
{
  struct
  {
    uint32 mdio0 : 2;                  /**< Bidirectional, push-pull management data I/O line MAC0*/
    uint32 mdio1 : 2;                  /**< Bidirectional, push-pull management data I/O line MAC1*/
    uint32 crs   : 2;                  /**< Carrier sense for only MII (::XMC_ETH_MAC_PORT_CTRL_CRS_t) */
    uint32 col   : 2;                  /**< Collision Detect for only MII (::XMC_ETH_MAC_PORT_CTRL_COL_t) */
    uint32 rxctl : 2;                  /**< Alternate Input Select - RXDV, CRSDV, RCTL */
    uint32 rxer  : 2;                  /**< Receive error (::XMC_ETH_MAC_PORT_CTRL_RXER_t) */
    uint32 rxd0  : 2;                  /**< Receive data bit 0 (::XMC_ETH_MAC_PORT_CTRL_RXD0_t) */
    uint32 rxd1  : 2;                  /**< Receive data bit 1 (::XMC_ETH_MAC_PORT_CTRL_RXD1_t) */
    uint32 rxd2  : 2;                  /**< Receive data bit 2 (only MII) (::XMC_ETH_MAC_PORT_CTRL_RXD2_t) */
    uint32 rxd3  : 2;                  /**< Receive data bit 3 (only MII) (::XMC_ETH_MAC_PORT_CTRL_RXD3_t) */
    uint32 clk_tx: 2;                  /**< alternate input for TXCLK */
    uint32 clk_rx: 2;                  /**< alternate input for RXCLK or REFCLK */
    uint32       : 4;                  /**< \brief \internal Reserved */
    uint32 mode  : 3;                  /**< \brief [24:24] External Phy Interface RMMI Mode Bit (rw) */
    uint32 fsr   : 1;                  /**< \brief \internal Reserved */
  };

  uint32 raw;
} HSPHY_ETH_PORT_CTRL_t;


/**
 * HSPHY MP8G control
 */
typedef union HSPHY_MP8G_CTRL
{
    IfxHsphy_PadNativeInterface MP8GInterface;
    IfxHsphy_SgmiiSpeed MP8GSgmiiSpeed;
} HSPHY_MP8G_CTRL_t;

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * @brief Enable the HSPHY module
 * @return SUCCESS or FAILURE
 */
sint32 HSPHY_Enable(void);

/**
 * @brief Init HSPHY instance
 * @param MP8G_PHY_p pointer to Phy software instance
 * @return SUCCESS or FAILURE
 */
sint32 HSPHY_Init_MP8G_Phy_Instance(HSPHY_MP8G_CTRL_t  const *MP8G_PHY_p);

/**
 * @brief Init the HSPHY.Port0 MDIO insterface
 * @param mdio MDIO pin selection
 * @return SUCCESS or FAILURE
 */
sint32 HSPHY_Init_Ethernet_Mdio0(IfxGeth_Mdio_InOut mdio);

/**
 * @brief Init the HSPHY.Port1 MDIO insterface
 * @param mdio MDIO pin selection
 * @return SUCCESS or FAILURE
 */
sint32 HSPHY_Init_Ethernet_Mdio1(IfxGeth_Mdio_InOut mdio);

/**
 * @brief Read a 16bit register value from the HSPHY module
 * @param hsphyInstance_p pointer to HSPHY module instance
 * @param phyIdx_u8 HSPHY port index
 * @param regAddr_u16 HSPHY register address
 * @param regData_u16_p pointer to the variable receiving the read value
 * @param timeOut_u32 timeout value for the hardware access
 * @return SUCCESS or FAILURE
 */
sint32 HSPHY_PhyReg_read(Ifx_HSPHY *const hsphyInstance_p, const uint8 phyIdx_u8, const uint16 regAddr_u16, uint16 *const regData_u16_p, uint32 timeOut_u32);

/**
 * @brief Write a 16bit register value to the HSPHY module
 * @param hsphyInstance_p pointer to HSPHY module instance
 * @param phyIdx_u8 HSPHY port index
 * @param regAddr_u16 HSPHY register address
 * @param regData_u16 new register value
 * @param timeOut_u32 timeout value for the hardware access
 * @return SUCCESS or FAILURE
 */
sint32 HSPHY_PhyReg_write(Ifx_HSPHY *const hsphyInstance_p, const uint8 phyIdx_u8, const uint16 regAddr_u16, const uint16 regData_u16, uint32 timeOut_u32);

/**
 * @brief Init the HSPHY to operate in 100Mbps mode
 * @param hsphyInstance_p pointer to HSPHY module instance
 * @param phyIdx_u8 HSPHY port index
 * @param timeOut_u32 timeout value for the hardware access
 * @return SUCCESS or FAILURE
 */
sint32 HSPHY_100M_Mode_Init(Ifx_HSPHY *const hsphyInstance_p, const uint8 phyIdx_u8, uint32 timeOut_u32);

/**
 * @brief Init the HSPHY to operate in 1Gbps mode
 * @param hsphyInstance_p pointer to HSPHY module instance
 * @param phyIdx_u8 HSPHY port index
 * @param timeOut_u32 timeout value for the hardware access
 * @return SUCCESS or FAILURE
 */
sint32 HSPHY_1G_Mode_Init(Ifx_HSPHY *const hsphyInstance_p, const uint8 phyIdx_u8, uint32 timeOut_u32);

/**
 * @brief Init the HSPHY to operate in 2.5Gbps mode
 * @param hsphyInstance_p pointer to HSPHY module instance
 * @param phyIdx_u8 HSPHY port index
 * @param timeOut_u32 timeout value for the hardware access
 */
sint32 HSPHY_2G5_Mode_Init(Ifx_HSPHY *const hsphyInstance_p, const uint8 phyIdx_u8, uint32 timeOut_u32);

/**
 * @brief Init the HSPHY to operate in 5Gbps mode
 * @param hsphyInstance_p pointer to HSPHY module instance
 * @param phyIdx_u8 HSPHY port index
 * @param timeOut_u32 timeout value for the hardware access
 */
sint32 HSPHY_5G_Mode_Init(Ifx_HSPHY *const hsphyInstance_p, const uint8 phyIdx_u8, uint32 timeOut_u32);

sint32 HSPHY_Init_Ethernet_Mdio(const uint8 phyIdx_u8, const IfxGeth_Mdio_InOut *mdio_p);
sint32 HSPHY_Init_Mode(Ifx_HSPHY *const hsphyInstance_p, const uint8 phyIdx_u8, const uint16 speed_u16);

sint32 HSPHY_Init_Ethernet_Crs(const uint8 ethIdx_u8, IfxGeth_Crs_In const *crs);
sint32 HSPHY_Init_Ethernet_Col(const uint8 ethIdx_u8, IfxGeth_Col_In const *col);
sint32 HSPHY_Init_Ethernet_RxCtl(const uint8 ethIdx_u8, IfxGeth_Rxctl_In const *rxctl);
sint32 HSPHY_Init_Ethernet_RxD0(const uint8 ethIdx_u8, IfxGeth_Rxd_In const *rxd0);
sint32 HSPHY_Init_Ethernet_RxD1(const uint8 ethIdx_u8, IfxGeth_Rxd_In const *rxd1);
sint32 HSPHY_Init_Ethernet_RxD2(const uint8 ethIdx_u8, IfxGeth_Rxd_In const *rxd2);
sint32 HSPHY_Init_Ethernet_RxD3(const uint8 ethIdx_u8, IfxGeth_Rxd_In const *rxd3);
sint32 HSPHY_Init_Ethernet_TxClk(const uint8 ethIdx_u8, IfxGeth_Txclk_Out const *txclk);
sint32 HSPHY_Init_Ethernet_RxClk(const uint8 ethIdx_u8, IfxGeth_Rxclk_In const *rxclk);

void Board_Hsphy_Mp8G_SetMuxToEth(void);
void Board_Hsphy_Mp8G_SetMuxToPcie(void);

#endif /* IFX_HSPHY_H */
