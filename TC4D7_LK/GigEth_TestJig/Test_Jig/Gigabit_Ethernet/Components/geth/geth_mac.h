/**********************************************************************************************************************
 * \file geth_mac.h
 * \brief Project configuration file.
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*******************************************************************************
**                             Author(s) Identity                             **
********************************************************************************
** Initials     Name                                                          **
** ---------------------------------------------------------------------------**
** RS           Ronny Schulze                                                 **
** DM           Daniel Mysliwitz                                              **
*******************************************************************************/

/*******************************************************************************
**                          Revision Control History                          **
********************************************************************************
** V0.1.0: 2021-11-16, DM:   Initial version                                  **
** V0.1.1: 2021-12-10, DM:   PORT[n].CORE.MAC_RXQ_CTRL1,                      **
**                           PORT[0].CORE.MAC_RXQ_CTRL2,                      **
**                           PORT[0].CORE.MAC_RXQ_CTRL3 initialization added  **
** V0.1.3: 2023-05-17, DM:   add frame duplication support                    **
** V0.1.4: 2023-05-24, DM:   add MAC_RXQ_CTRL4                                **
** V0.1.5: 2023-06-21, DM:   fix Geth_Mac_Vlan_Incl_Write() to only perform   **
**                           register access if enabled in SD                 **
*******************************************************************************/

#ifndef IFX_XGMAC_H
#define IFX_XGMAC_H 1

#include <string.h>
#include "Ifx_Types.h"
#include "types.h"
#include "geth_mdio.h"
#include "IfxGeth_Eth.h"
#include "IfxGeth_reg.h"

#ifdef IFX_SOLUTION_DESIGNER_GETH_ENABLE
    #include "tc4d_geth_mac_cfg.h"
#endif /* IFX_SOLUTION_DESIGNER_GETH_ENABLE */

/**********************************************************************************************************************
 * MACROS
 *********************************************************************************************************************/
#define GETH_MAC_NUMBER_OF_QUEUES (8u)
#define GETH_MAC_NUMBER_OF_MACS (2u)

#define GETH_MAC0 (0u)
#define GETH_MAC1 (1u)

#define GETH_MAC0_MASK (1u)
#define GETH_MAC1_MASK (2u)

#define GETH_MAC_QUEUE0 (0u)
#define GETH_MAC_QUEUE1 (1u)
#define GETH_MAC_QUEUE2 (2u)
#define GETH_MAC_QUEUE3 (3u)
#define GETH_MAC_QUEUE4 (4u)
#define GETH_MAC_QUEUE5 (5u)
#define GETH_MAC_QUEUE6 (6u)
#define GETH_MAC_QUEUE7 (7u)

#define GETH_MAC_ADDR0 (0u)
#define GETH_MAC_ADDR1 (1u)
#define GETH_MAC_ADDR2 (2u)
#define GETH_MAC_ADDR3 (3u)
#define GETH_MAC_ADDR4 (4u)
#define GETH_MAC_ADDR5 (5u)
#define GETH_MAC_ADDR6 (6u)
#define GETH_MAC_ADDR7 (7u)
#define GETH_MAC_ADDR8 (8u)

#define GETH_NO_OF_TIMESTAMPS (16)

#define GETH_MAC_GCL_BTR_LOW_ADDR  (0u)
#define GETH_MAC_GCL_BTR_HIGH_ADDR (1u)
#define GETH_MAC_GCL_CTR_LOW_ADDR  (2u)
#define GETH_MAC_GCL_CTR_HIGH_ADDR (3u)
#define GETH_MAC_GCL_TER_ADDR      (4u)
#define GETH_MAC_GCL_LLR_ADDR      (5u)

#define GETH_PORT0_EN (GETH_MACEN & 1)
#define GETH_PORT1_EN ((GETH_MACEN >> 1) & 1)

/**********************************************************************************************************************
 * ENUMS
 *********************************************************************************************************************/
/**
 * ETH link speed
 */
typedef enum ETH_MAC_LINK_SPEED
{
  ETH_MAC_LINK_SPEED_10M    = 7UL, /**< Link speed: 10M */
  ETH_MAC_LINK_SPEED_100M   = 4UL, /**< Link speed: 100M */
  ETH_MAC_LINK_SPEED_1000M  = 3UL, /**< Link speed: 1000M */
  ETH_MAC_LINK_SPEED_2500M  = 2UL, /**< Link speed: 2500M */
  ETH_MAC_LINK_SPEED_5000M  = 5UL, /**< Link speed: 5000M */
} ETH_MAC_LINK_SPEED_t;

/**
 * ETH duplex settings (full/half?)
 */
typedef enum ETH_MAC_LINK_MODE
{
  ETH_MAC_LINK_MODE_HALF_DUPLEX = 0UL, /**< Half duplex */
  ETH_MAC_LINK_MODE_FULL_DUPLEX = 1UL  /**< Full duplex */
} ETH_MAC_LINK_MODE_t;


typedef enum ETH_MAC_L3L4_OPCODE
{
    ETH_MAC_L3L4_OPCODE_CTRL = 0u,     /**< MAC_L3_L4_CONTROL */
    ETH_MAC_L3L4_OPCODE_L4_ADDR = 1u,  /**< MAC_Layer4_Address */
    ETH_MAC_L3L4_OPCODE_L3_ADDR0 = 4u, /**< MAC_Layer3_Address0 */
    ETH_MAC_L3L4_OPCODE_L3_ADDR1 = 5u, /**< MAC_Layer3_Address1 */
    ETH_MAC_L3L4_OPCODE_L3_ADDR2 = 6u, /**< MAC_Layer3_Address2 */
    ETH_MAC_L3L4_OPCODE_L3_ADDR3 = 7u  /**< MAC_Layer3_Address3 */
} ETH_MAC_L3L4_OPCODE_t;

/**********************************************************************************************************************
 * DATA STRUCTURES
 *********************************************************************************************************************/
typedef struct
{
  uint8 mac_addr[6];

  union
  {
    struct
    {
      unsigned int dma_channel_select : 2;
      unsigned int : 6;
      unsigned int mask_byte_control : 6;
      unsigned int source_address : 1;
      unsigned int enable : 1;
    };
    uint16 config;
  };
} ETH_MAC_ADDR_FILTER_t;
/*
typedef struct
{
    uint8 used;
    uint16 packedId;
    uint16 secOverflow;
    uint32 second;
    uint32 nanoSecond;
} Sys_TimeStamp_t;
*/
typedef struct
{
    Ifx_GETH *gethInstance_p;
    Sys_TimeStamp_t timeStamp[GETH_MAC_NUMBER_OF_MACS][GETH_NO_OF_TIMESTAMPS];
    uint8 initDone_u8;
    uint8 irqInitDone_u8;
} GethMac_t;

/**********************************************************************************************************************
 * API PROTOTYPES
 *********************************************************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

static inline sint32 Geth_isModuleEnabled(Ifx_GETH *const gethInstance_p, boolean *const enabled_p);

/**
 * @brief Initializes the MAC software structure based on ConfigWizard settings
 * @param macInstance_p pointer to the ethernet register block
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Mac_initStruct(Ifx_GETH *const gethInstance_p);

/**
 * @brief Initializes the MAC0 based on ConfigWizard settings
 * @param macInstance_p pointer to the ethernet register block
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Mac0_Init(void);

/**
 * @brief Initializes the MAC1 based on ConfigWizard settings
 * @param macInstance_p pointer to the ethernet register block
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Mac1_Init(void);

/**
 * @brief Enables the MAC ports
 * @param gethPortEnMask_u8 MAC port enable mask value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Mac_enablePort(const uint8 gethPortEnMask_u8);

/**
 * @brief Initializes the MAC transmit queue
 * @param gethPort_u8 MAC port value
 * @param queueIndex_u8 MAC queue value
 * @param transmitClass_u8 transmit class used for that queue
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Mac_TxQueue_Init(const uint8 gethPort_u8, const uint8 queueIndex_u8, const uint8 transmitClass_u8);

/**
 * @brief Initializes the MAC receive queue
 * @param gethPort_u8 MAC port value
 * @param queueIndex_u8 MAC queue value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Mac_RxQueue_Init(const uint8 gethPort_u8, const uint8 queueIndex_u8);

/**
 * @brief Initializes the timestaming configuration for the MAC
 * @param gethPort_u8 MAC port value
 * @return (void)
 */
sint32 Geth_Mac_TimeStamping_Init(const uint8 gethPort_u8);

/**
 * @brief Enable the MAC for transmitting and receiving
 * @param gethPort_u8 MAC port value
 * @return TRUE = success
 */
sint32 Geth_Mac_enableTransmitReceive(const uint8 gethPort_u8);

/**
 * @brief Disable the MAC for transmitting and receiving
 * @param gethPort_u8 MAC port value
 * @return TRUE = success
 */
sint32 Geth_Mac_disableTransmitReceive(const uint8 gethPort_u8);

/**
 * @brief Enable the MAC for transmitting
 * @param gethPort_u8 MAC port value
 * @return TRUE = success
 */
sint32 Geth_Mac_enableTransmit(const uint8 gethPort_u8);

/**
 * @brief Enable the MAC for receiving
 * @param gethPort_u8 MAC port value
 * @return TRUE = success
 */
sint32 Geth_Mac_enableReceive(const uint8 gethPort_u8);

/**
 * @brief Writes a 32bit Layer3/4 filter word
 * @param gethPort_u8 MAC port value
 * @param filtIdx_u8 filter index
 * @param opCode_t filter address select opcode
 * @param regValue_u32 filter value
 * @return TRUE = success
 */
sint32 Geth_Mac_L3L4_Filter_writeDword(const uint8 gethPort_u8, const uint8 filtIdx_u8, const ETH_MAC_L3L4_OPCODE_t opCode_t, const uint32 regValue_u32);

/**
 * @brief Reads a 32bit Layer3/4 filter word
 * @param gethPort_u8 MAC port value
 * @param filtIdx_u8 filter index
 * @param opCode_t filter address select opcode
 * @param regValue_p filter value return
 * @return TRUE = success
 */
sint32 Geth_Mac_L3L4_Filter_readDword(const uint8 gethPort_u8, const uint8 filtIdx_u8, const ETH_MAC_L3L4_OPCODE_t opCode_t, uint32 *const regValue_p);

/**
 * @brief Checks whether GETH module is enabled
 * @param gethInstance_p GETH module instance pointer
 * @param enabled_p enable value return
 * @return TRUE = success
 */
static inline sint32 Geth_isModuleEnabled(Ifx_GETH *const gethInstance_p, boolean *const enabled_p)
{
    if (gethInstance_p == NULL)
    {
      return FALSE;
    }

    *enabled_p = (gethInstance_p->CLC.B.DISS == 0) ? TRUE : FALSE;
    return SUCCESS;
}

/**
 * @brief Writes indirect registers for Extended DMA select0
 * @param gethPort_u8 MAC port value
 * @param filtIdx_u8 index to the indirect register, 0..31
 * @param regValue_u32 register value, XDCS
 * @return TRUE = success
 */
sint32 Geth_Mac_DmaSel_Write(const uint8 gethPort_u8, const uint8 filtIdx_u8, const uint32 regValue_u32);

/**
 * @brief Enables the Interrupt service request for GETH interrupts
 * @param typeOfService selecting interrupt service provider
 * @param priority interrupt priority value
 * @return TRUE = success
 */
sint32 Geth_Mac_enableServiceRequest(const IfxSrc_Tos typeOfService, const Ifx_Priority priority);

/**
 * @brief Reads the VLAN inclusion register
 * @param gethPort_u8 MAC port value, 0..1
 * @param regIdx_u8 VLAN inclusion register index, 0..7
 * @param regValue_p register content return value
 * @return TRUE = success
 */
sint32 Geth_Mac_Vlan_Incl_Read(const uint8 gethPort_u8, const uint8 regIdx_u8, uint32 *const regValue_p);

/**
 * @brief Reads the current Tx timestamp from timestamp fifo
 * @param gethPort_u8 MAC port value, 0..1
 * @param timeStamp_p timestamp content return value
 * @return TRUE = success
 */
sint32 Geth_Mac_getTxTimestamp(const uint8 gethPort_u8, Sys_TimeStamp_t* const timeStamp_p);
sint32 Geth_Mac_getFetchedTxTimestamp(const uint8 gethPort_u8, const uint16 packetId_u16, Sys_TimeStamp_t* const timeStamp_p);

/**
 * @brief Updates the system time by addition of systemTimeUpdate_p
 * @param gethPort_u8 MAC port value, 0..1
 * @param systemTimeUpdate_p pointer to update time
 * @return TRUE = success
 */
sint32 Geth_Mac_updateSysTimeAdd(const uint8 gethPort_u8, Sys_TimeStamp_t* const systemTimeUpdate_p);

/**
 * @brief Updates the system time by subtraction of systemTimeUpdate_p
 * @param gethPort_u8 MAC port value, 0..1
 * @param systemTimeUpdate_p pointer to update time
 * @return TRUE = success
 */
sint32 Geth_Mac_updateSysTimeSub(const uint8 gethPort_u8, Sys_TimeStamp_t* const systemTimeUpdate_p);

sint32 Geth_Mac_Vlan_Incl_Read(const uint8 gethPort_u8, const uint8 regIdx_u8, uint32 *const regValue_p);

void Geth_timeStampHandler(const uint8 gethPort_u8);

sint32 Geth_Mac_setLinkSpeed(const uint8 gethPort_u8, const uint16 linkSpeed_u16);
sint32 Geth_Mac_TAS_enableSoftwareList(const uint8 gethPort_u8);
sint32 Geth_Mac_TAS_disableSoftwareList(const uint8 gethPort_u8);
boolean Geth_Mac_TAS_isSoftwareListActive(const uint8 gethPort_u8);

sint32 Geth_Mac_PolicyCounterCtrl_Write(const uint8 gethPort_u8, const uint8 pccIdx_u8, const uint32 regValue_u32);
sint32 Geth_Mac_PolicyCounter_Write(const uint8 gethPort_u8, const uint8 pcIdx_u8, const uint32 regValue_u32);
sint32 Geth_Mac_PolicyCounter_Read(const uint8 gethPort_u8, const uint8 pcIdx_u8, uint32 * const regValue_p);
sint32 Geth_Mac_DstSrcPlcySel_Write(const uint8 gethPort_u8, const uint8 daIdx_u8, const uint32 regValue_u32);
sint32 Geth_Mac_FailPlcySel_Write(const uint8 gethPort_u8, const uint8 daIdx_u8, const uint32 regValue_u32);

#ifdef __cplusplus
}
#endif

#endif /* IFX_XGMAC_H */
