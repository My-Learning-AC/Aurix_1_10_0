/**
 * \file geth_mac.c
 * \brief Functions to interface to the Geth MAC
 *
 * \version see header file
 * \copyright Copyright (c) 2019-2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#include <stdio.h>
#include <string.h>
#include "geth_mac.h"
#include "IfxClock.h"
#include "Ifx_Types.h"
#include "types.h"
#include "IfxPort_PinMap.h"
#include "IfxGeth_PinMap.h"
#include "IfxPort.h"

#ifdef IFX_SOLUTION_DESIGNER_GETH_ENABLE
#include "tc4d_geth_mac_cfg.h"
#include "geth_mac_a.h"
#endif

#ifdef IFX_SOLUTION_DESIGNER_GETH_ENABLE
//sint32 Geth_Mac_Vlan_Incl_Write(const uint8 gethPort_u8, const uint8 regIdx_u8, const uint32 vlanInclValue_u32);
sint32 Geth_Mac_Vlan_Incl_Write(const uint8 gethPort_u8, const uint8 regIdx_u8, const uint32 globalVlanInclValue_u32, const uint32 localVlanInclValue_u32);
sint32 Geth_Mac_Vlan_Filter_Write(const uint8 gethPort_u8, const uint8 vlanFiltIdx_u8, const uint32 vlanFiltValue_u32);
#endif /* IFX_SOLUTION_DESIGNER_GETH_ENABLE */

#if ((GETH_PORT0_MTL_EST_INTR_ENABLE & (IFX_GETH_PORT_MTL_EST_INTR_ENABLE_IECC_MSK << IFX_GETH_PORT_MTL_EST_INTR_ENABLE_IECC_OFF)) != 0)
    extern void GETH_PORT0_MTL_EST_INTR_ENABLE_IECC_ISR(void);
#endif
#if ((GETH_PORT0_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_OFF)) != 0)
    extern void GETH_PORT0_MAC_INTERRUPT_ENABLE_TSIE_ISR(void);
#endif /* ((GETH_DMA_CH0_INTERRUPT_ENABLE & (IFX_GETH_DMA_CH_INTERRUPT_ENABLE_TIE_MSK << IFX_GETH_DMA_CH_INTERRUPT_ENABLE_TIE_OFF)) != 0) */
#if ((GETH_PORT0_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_OFF)) != 0)
    extern void GETH_PORT0_MAC_INTERRUPT_ENABLE_TXESIS_ISR(void);
#endif /* ((GETH_PORT0_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_OFF)) != 0) */
#if ((GETH_PORT0_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_OFF)) != 0)
    extern void GETH_PORT0_MAC_INTERRUPT_ENABLE_RXESIS_ISR(void);
#endif /* ((GETH_PORT0_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_OFF)) != 0) */
#if ((GETH_PORT0_MAC_PCTH_INTR_ENABLE & 1) != 0)
    extern void GETH_PORT0_MAC_PCTH_INTR_ENABLE_ISR0(void);
#endif

#if ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_OFF)) != 0)
    extern void GETH_PORT1_MAC_INTERRUPT_ENABLE_TSIE_ISR(void);
#endif /* ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_OFF)) != 0) */
#if ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_OFF)) != 0)
    extern void GETH_PORT1_MAC_INTERRUPT_ENABLE_TXESIS_ISR(void);
#endif /* ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_OFF)) != 0) */
#if ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_OFF)) != 0)
    extern void GETH_PORT1_MAC_INTERRUPT_ENABLE_RXESIS_ISR(void);
#endif /* ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_OFF)) != 0) */

static GethMac_t g_gethMac;
static boolean g_mac0Initialized_b = FALSE;
static boolean g_mac1Initialized_b = FALSE;

sint32 Geth_Mac_initStruct(Ifx_GETH *const gethInstance_p)
{
    if (gethInstance_p == NULL)
    {
      return FAILURE;
    }

    memset(&g_gethMac, 0, sizeof(GethMac_t));

    g_gethMac.gethInstance_p = gethInstance_p;

    g_gethMac.initDone_u8 = 1;
    return SUCCESS;
}

sint32 Geth_Mac_enablePort(const uint8 gethPortEnMask_u8)
{
    if (g_gethMac.initDone_u8 == 0)
    {
      return FAILURE;
    }

    g_gethMac.gethInstance_p->MACEN.U = gethPortEnMask_u8 & 3u;

    return SUCCESS;
}

sint32 Geth_Mac_writeGcl(const uint8 gethPort_u8, const uint8 tgtSel_u8, const uint8 addr_u8, const uint32 data_u32)
{
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS))
    {
      return FAILURE;
    }

    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_DATA.U = data_u32;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.ADDR = addr_u8;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.R1W0 = 0; /* write */
    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.GCRR = tgtSel_u8 & 1;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.GCLS = 0; /* 0 = EST, 1 = SGF */
    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.SRWO = 1;

    while (g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.SRWO == 1) {}

    return SUCCESS;
}

sint32 Geth_Mac_readGcl(const uint8 gethPort_u8, const uint8 tgtSel_u8, const uint8 addr_u8, uint32 * const data_p)
{
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (data_p == NULL))
    {
      return FAILURE;
    }

    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.ADDR = addr_u8;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.R1W0 = 1; /* read */
    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.GCRR = tgtSel_u8 & 1;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.GCLS = 0; /* 0 = EST, 1 = SGF */
    g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.SRWO = 1;

    while (g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_CONTROL.B.SRWO == 1) {}

    *data_p = g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.GCL_DATA.U;

    return SUCCESS;
}

/*
 * GETH Init function
 */
sint32 Geth_Mac0_Init(void)
{
    Ifx_GETH* gethInstance_p;

    if (g_gethMac.initDone_u8 == 0)
    {
        return FAILURE;
    }

    if (g_mac0Initialized_b == TRUE)
    {
        return SUCCESS;
    }

    gethInstance_p = g_gethMac.gethInstance_p;

#ifdef IFX_SOLUTION_DESIGNER_GETH_ENABLE

    gethInstance_p->PORT[0].MTL.ECC_CONTROL.U = GETH_PORT0_MTL_ECC_CONTROL;
    gethInstance_p->PORT[0].CORE.MAC_EXTENDED_CONFIGURATION.U = GETH_PORT0_MAC_EXTENDED_CONFIGURATION;

    gethInstance_p->PORT[0].CORE.MAC_TX_CONFIGURATION.U = GETH_PORT0_MAC_TX_CONFIGURATION;
    gethInstance_p->PORT[0].CORE.MAC_RX_CONFIGURATION.U = GETH_PORT0_MAC_RX_CONFIGURATION;
    gethInstance_p->PORT[0].MTL.OPERATION_MODE.U = GETH_PORT0_MTL_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.RXQ_DMA_MAP0.U = GETH_PORT0_MTL_RXQ_DMA_MAP0;
    gethInstance_p->PORT[0].MTL.RXQ_DMA_MAP1.U = GETH_PORT0_MTL_RXQ_DMA_MAP1;

    gethInstance_p->PORT[0].MTL.TCQ0.TC0_QUANTUM_WEIGHT.U = GETH_PORT0_MTL_TC0_QUANTUM_WEIGHT;
    gethInstance_p->PORT[0].MTL.TCQ1.TC1_QUANTUM_WEIGHT.U = GETH_PORT0_MTL_TC1_QUANTUM_WEIGHT;
    gethInstance_p->PORT[0].MTL.TCQ2.TC2_QUANTUM_WEIGHT.U = GETH_PORT0_MTL_TC2_QUANTUM_WEIGHT;
    gethInstance_p->PORT[0].MTL.TCQ3.TC3_QUANTUM_WEIGHT.U = GETH_PORT0_MTL_TC3_QUANTUM_WEIGHT;
    gethInstance_p->PORT[0].MTL.TCQ4.TC4_QUANTUM_WEIGHT.U = GETH_PORT0_MTL_TC4_QUANTUM_WEIGHT;
    gethInstance_p->PORT[0].MTL.TCQ5.TC5_QUANTUM_WEIGHT.U = GETH_PORT0_MTL_TC5_QUANTUM_WEIGHT;
    gethInstance_p->PORT[0].MTL.TCQ6.TC6_QUANTUM_WEIGHT.U = GETH_PORT0_MTL_TC6_QUANTUM_WEIGHT;
    gethInstance_p->PORT[0].MTL.TCQ7.TC7_QUANTUM_WEIGHT.U = GETH_PORT0_MTL_TC7_QUANTUM_WEIGHT;

    gethInstance_p->PORT[0].MTL.TCQ0.TC0_ETS_CONTROL.U = GETH_PORT0_MTL_TC0_ETS_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ1.TC1_ETS_CONTROL.U = GETH_PORT0_MTL_TC1_ETS_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ2.TC2_ETS_CONTROL.U = GETH_PORT0_MTL_TC2_ETS_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ3.TC3_ETS_CONTROL.U = GETH_PORT0_MTL_TC3_ETS_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ4.TC4_ETS_CONTROL.U = GETH_PORT0_MTL_TC4_ETS_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ5.TC5_ETS_CONTROL.U = GETH_PORT0_MTL_TC5_ETS_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ6.TC6_ETS_CONTROL.U = GETH_PORT0_MTL_TC6_ETS_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ7.TC7_ETS_CONTROL.U = GETH_PORT0_MTL_TC7_ETS_CONTROL;

    gethInstance_p->PORT[0].MTL.TCQ5.TC5_HICREDIT.U = GETH_PORT0_MTL_TC5_HICREDIT;
    gethInstance_p->PORT[0].MTL.TCQ6.TC6_HICREDIT.U = GETH_PORT0_MTL_TC6_HICREDIT;
    gethInstance_p->PORT[0].MTL.TCQ7.TC7_HICREDIT.U = GETH_PORT0_MTL_TC7_HICREDIT;

    gethInstance_p->PORT[0].MTL.TCQ5.TC5_LOCREDIT.U = GETH_PORT0_MTL_TC5_LOCREDIT;
    gethInstance_p->PORT[0].MTL.TCQ6.TC6_LOCREDIT.U = GETH_PORT0_MTL_TC6_LOCREDIT;
    gethInstance_p->PORT[0].MTL.TCQ7.TC7_LOCREDIT.U = GETH_PORT0_MTL_TC7_LOCREDIT;

    gethInstance_p->PORT[0].MTL.TCQ5.TC5_SENDSLOPECREDIT.U = GETH_PORT0_MTL_TC5_SENDSLOPECREDIT;
    gethInstance_p->PORT[0].MTL.TCQ6.TC6_SENDSLOPECREDIT.U = GETH_PORT0_MTL_TC6_SENDSLOPECREDIT;
    gethInstance_p->PORT[0].MTL.TCQ7.TC7_SENDSLOPECREDIT.U = GETH_PORT0_MTL_TC7_SENDSLOPECREDIT;

    gethInstance_p->PORT[0].MTL.TCQ0.TXQ0_OPERATION_MODE.U = GETH_PORT0_MTL_TXQ0_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ1.TXQ1_OPERATION_MODE.U = GETH_PORT0_MTL_TXQ1_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ2.TXQ2_OPERATION_MODE.U = GETH_PORT0_MTL_TXQ2_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ3.TXQ3_OPERATION_MODE.U = GETH_PORT0_MTL_TXQ3_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ4.TXQ4_OPERATION_MODE.U = GETH_PORT0_MTL_TXQ4_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ5.TXQ5_OPERATION_MODE.U = GETH_PORT0_MTL_TXQ5_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ6.TXQ6_OPERATION_MODE.U = GETH_PORT0_MTL_TXQ6_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ7.TXQ7_OPERATION_MODE.U = GETH_PORT0_MTL_TXQ7_OPERATION_MODE;

    gethInstance_p->PORT[0].MTL.TCQ0.RXQ0_OPERATION_MODE.U = GETH_PORT0_MTL_RXQ0_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ1.RXQ1_OPERATION_MODE.U = GETH_PORT0_MTL_RXQ1_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ2.RXQ2_OPERATION_MODE.U = GETH_PORT0_MTL_RXQ2_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ3.RXQ3_OPERATION_MODE.U = GETH_PORT0_MTL_RXQ3_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ4.RXQ4_OPERATION_MODE.U = GETH_PORT0_MTL_RXQ4_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ5.RXQ5_OPERATION_MODE.U = GETH_PORT0_MTL_RXQ5_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ6.RXQ6_OPERATION_MODE.U = GETH_PORT0_MTL_RXQ6_OPERATION_MODE;
    gethInstance_p->PORT[0].MTL.TCQ7.RXQ7_OPERATION_MODE.U = GETH_PORT0_MTL_RXQ7_OPERATION_MODE;

    gethInstance_p->PORT[0].MTL.TCQ0.RXQ0_CONTROL.U = GETH_PORT0_MTL_RXQ0_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ1.RXQ1_CONTROL.U = GETH_PORT0_MTL_RXQ1_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ2.RXQ2_CONTROL.U = GETH_PORT0_MTL_RXQ2_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ3.RXQ3_CONTROL.U = GETH_PORT0_MTL_RXQ3_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ4.RXQ4_CONTROL.U = GETH_PORT0_MTL_RXQ4_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ5.RXQ5_CONTROL.U = GETH_PORT0_MTL_RXQ5_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ6.RXQ6_CONTROL.U = GETH_PORT0_MTL_RXQ6_CONTROL;
    gethInstance_p->PORT[0].MTL.TCQ7.RXQ7_CONTROL.U = GETH_PORT0_MTL_RXQ7_CONTROL;

    gethInstance_p->PORT[0].CORE.MAC_RXQ_CTRL0.U = GETH_PORT0_MAC_RXQ_CTRL0;
    gethInstance_p->PORT[0].CORE.MAC_RXQ_CTRL1.U = GETH_PORT0_MAC_RXQ_CTRL1;
    gethInstance_p->PORT[0].CORE.MAC_RXQ_CTRL2.U = GETH_PORT0_MAC_RXQ_CTRL2;
    gethInstance_p->PORT[0].CORE.MAC_RXQ_CTRL3.U = GETH_PORT0_MAC_RXQ_CTRL3;
    gethInstance_p->PORT[0].CORE.MAC_RXQ_CTRL4.U = GETH_PORT0_MAC_RXQ_CTRL4;

    gethInstance_p->PORT[0].CORE.MACADDRESS0.HIGH.U = GETH_PORT0_MAC_ADDRESS0_HIGH;
    gethInstance_p->PORT[0].CORE.MACADDRESS0.LOW.U =  GETH_PORT0_MAC_ADDRESS0_LOW;
    gethInstance_p->PORT[0].CORE.MACADDRESS1.HIGH.U = GETH_PORT0_MAC_ADDRESS1_HIGH;
    gethInstance_p->PORT[0].CORE.MACADDRESS1.LOW.U =  GETH_PORT0_MAC_ADDRESS1_LOW;
    gethInstance_p->PORT[0].CORE.MACADDRESS2.HIGH.U = GETH_PORT0_MAC_ADDRESS2_HIGH;
    gethInstance_p->PORT[0].CORE.MACADDRESS2.LOW.U =  GETH_PORT0_MAC_ADDRESS2_LOW;
    gethInstance_p->PORT[0].CORE.MACADDRESS3.HIGH.U = GETH_PORT0_MAC_ADDRESS3_HIGH;
    gethInstance_p->PORT[0].CORE.MACADDRESS3.LOW.U =  GETH_PORT0_MAC_ADDRESS3_LOW;
    gethInstance_p->PORT[0].CORE.MACADDRESS4.HIGH.U = GETH_PORT0_MAC_ADDRESS4_HIGH;
    gethInstance_p->PORT[0].CORE.MACADDRESS4.LOW.U =  GETH_PORT0_MAC_ADDRESS4_LOW;
    gethInstance_p->PORT[0].CORE.MACADDRESS5.HIGH.U = GETH_PORT0_MAC_ADDRESS5_HIGH;
    gethInstance_p->PORT[0].CORE.MACADDRESS5.LOW.U =  GETH_PORT0_MAC_ADDRESS5_LOW;
    gethInstance_p->PORT[0].CORE.MACADDRESS6.HIGH.U = GETH_PORT0_MAC_ADDRESS6_HIGH;
    gethInstance_p->PORT[0].CORE.MACADDRESS6.LOW.U =  GETH_PORT0_MAC_ADDRESS6_LOW;
    gethInstance_p->PORT[0].CORE.MACADDRESS7.HIGH.U = GETH_PORT0_MAC_ADDRESS7_HIGH;
    gethInstance_p->PORT[0].CORE.MACADDRESS7.LOW.U =  GETH_PORT0_MAC_ADDRESS7_LOW;
    gethInstance_p->PORT[0].CORE.MACADDRESS8.HIGH.U = GETH_PORT0_MAC_ADDRESS8_HIGH;
    gethInstance_p->PORT[0].CORE.MACADDRESS8.LOW.U =  GETH_PORT0_MAC_ADDRESS8_LOW;

    Geth_Mac_DmaSel_Write(GETH_MAC0, 0, GETH_PORT0_MAC_DCHSEL_INDREG0);
    Geth_Mac_DmaSel_Write(GETH_MAC0, 1, GETH_PORT0_MAC_DCHSEL_INDREG1);
    Geth_Mac_DmaSel_Write(GETH_MAC0, 2, GETH_PORT0_MAC_DCHSEL_INDREG2);
    Geth_Mac_DmaSel_Write(GETH_MAC0, 3, GETH_PORT0_MAC_DCHSEL_INDREG3);
    Geth_Mac_DmaSel_Write(GETH_MAC0, 4, GETH_PORT0_MAC_DCHSEL_INDREG4);
    Geth_Mac_DmaSel_Write(GETH_MAC0, 5, GETH_PORT0_MAC_DCHSEL_INDREG5);
    Geth_Mac_DmaSel_Write(GETH_MAC0, 6, GETH_PORT0_MAC_DCHSEL_INDREG6);
    Geth_Mac_DmaSel_Write(GETH_MAC0, 7, GETH_PORT0_MAC_DCHSEL_INDREG7);
    Geth_Mac_DmaSel_Write(GETH_MAC0, 8, GETH_PORT0_MAC_DCHSEL_INDREG8);
    Geth_Mac_DmaSel_Write(GETH_MAC0, 9, GETH_PORT0_MAC_DCHSEL_INDREG9);

    gethInstance_p->PORT[0].CORE.MAC_VLAN_TAG_CTRL.U = GETH_PORT0_MAC_VLAN_TAG_CTRL;
    gethInstance_p->PORT[0].CORE.MAC_INNER_VLAN_INCL.U = GETH_PORT0_MAC_INNER_VLAN_INCL;
#if 1
    Geth_Mac_Vlan_Incl_Write(GETH_MAC0, GETH_MAC_QUEUE0, GETH_PORT0_MAC_VLAN_INCL, GETH_PORT0_MAC_VLAN_INCL0);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC0, GETH_MAC_QUEUE1, GETH_PORT0_MAC_VLAN_INCL, GETH_PORT0_MAC_VLAN_INCL1);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC0, GETH_MAC_QUEUE2, GETH_PORT0_MAC_VLAN_INCL, GETH_PORT0_MAC_VLAN_INCL2);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC0, GETH_MAC_QUEUE3, GETH_PORT0_MAC_VLAN_INCL, GETH_PORT0_MAC_VLAN_INCL3);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC0, GETH_MAC_QUEUE4, GETH_PORT0_MAC_VLAN_INCL, GETH_PORT0_MAC_VLAN_INCL4);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC0, GETH_MAC_QUEUE5, GETH_PORT0_MAC_VLAN_INCL, GETH_PORT0_MAC_VLAN_INCL5);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC0, GETH_MAC_QUEUE6, GETH_PORT0_MAC_VLAN_INCL, GETH_PORT0_MAC_VLAN_INCL6);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC0, GETH_MAC_QUEUE7, GETH_PORT0_MAC_VLAN_INCL, GETH_PORT0_MAC_VLAN_INCL7);
#endif
    gethInstance_p->PORT[0].CORE.MAC_PACKET_FILTER.U = GETH_PORT0_MAC_PACKET_FILTER;
    gethInstance_p->PORT[0].CORE.MAC_PACKET_FILTER.B.RA = 0x1;
    gethInstance_p->PORT[0].CORE.MAC_PACKET_FILTER.B.PM = 0x1;
    gethInstance_p->PORT[0].CORE.MAC_PACKET_FILTER.B.PR = 0x1;

#if 1
    Geth_Mac_Vlan_Filter_Write(GETH_MAC0, GETH_MAC_QUEUE0, GETH_PORT0_MAC_VLAN_TAG_FILTER0);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC0, GETH_MAC_QUEUE1, GETH_PORT0_MAC_VLAN_TAG_FILTER1);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC0, GETH_MAC_QUEUE2, GETH_PORT0_MAC_VLAN_TAG_FILTER2);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC0, GETH_MAC_QUEUE3, GETH_PORT0_MAC_VLAN_TAG_FILTER3);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC0, GETH_MAC_QUEUE4, GETH_PORT0_MAC_VLAN_TAG_FILTER4);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC0, GETH_MAC_QUEUE5, GETH_PORT0_MAC_VLAN_TAG_FILTER5);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC0, GETH_MAC_QUEUE6, GETH_PORT0_MAC_VLAN_TAG_FILTER6);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC0, GETH_MAC_QUEUE7, GETH_PORT0_MAC_VLAN_TAG_FILTER7);
#endif
    /* 2. enable time stamping */
    gethInstance_p->PORT[0].CORE.MAC_TIMESTAMP_CONTROL.U = GETH_PORT0_MAC_TIMESTAMP_CONTROL;
    /* 3. Program sub second increment based on PTP frequency */
    gethInstance_p->PORT[0].CORE.MAC_SUB_SECOND_INCREMENT.B.SSINC =  (uint32)1E9 / GETH_PORT0_MAC_TIMESTAMP_FPTP;
    gethInstance_p->PORT[0].CORE.MAC_SUB_SECOND_INCREMENT.B.SNSINC = (((double)1E9 / (double)GETH_PORT0_MAC_TIMESTAMP_FPTP) - (uint32)(1E9 / GETH_PORT0_MAC_TIMESTAMP_FPTP)) * 256;
    /* 2^32 / fGETH / fPTP */
    gethInstance_p->PORT[0].CORE.MAC_TIMESTAMP_ADDEND.B.TSAR = (uint32)((double)(1ull << 32u) / (double)(IfxClock_getXGeth0Frequency() / (float32)GETH_PORT0_MAC_TIMESTAMP_FPTP));
    /* 4. optional, start updating the time stamp addend register to the PTP clock */
    gethInstance_p->PORT[0].CORE.MAC_TIMESTAMP_CONTROL.B.TSADDREG = 1u;
    /* 5. optionally, wait until the update is done */
    while (gethInstance_p->PORT[0].CORE.MAC_TIMESTAMP_CONTROL.B.TSADDREG == 1u) {}
    /* 6. optional, set Fine or Coarse time stamp Update */
    gethInstance_p->PORT[0].CORE.MAC_TIMESTAMP_CONTROL.B.TSCFUPDT = 1u;
    /* 7. Program MAC_System_Time_Seconds_Update Register and MAC_System_Time_Nanoseconds_Update */
    gethInstance_p->PORT[0].CORE.MAC_SYSTEM_TIME_SECONDS_UPDATE.U = 0u;
    gethInstance_p->PORT[0].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.U = 0u;
    /* 8. Initialize time stamp */
    gethInstance_p->PORT[0].CORE.MAC_TIMESTAMP_CONTROL.B.TSINIT = 1u;

    gethInstance_p->PORT[0].CORE.MAC_PPS0_TARGET_TIME_SECONDS.U = GETH_PORT0_MAC_PPS0_TARGET_TIME_SECONDS;
    gethInstance_p->PORT[0].CORE.MAC_PPS0_TARGET_TIME_NANOSECONDS.U = GETH_PORT0_MAC_PPS0_TARGET_TIME_NANOSECONDS;
    while (gethInstance_p->PORT[0].CORE.MAC_PPS0_TARGET_TIME_NANOSECONDS.B.TRGTBUSY0 == 1) {}

    gethInstance_p->PORT[0].CORE.MAC_PPS0_INTERVAL.U = GETH_PORT0_MAC_PPS0_INTERVAL;
    gethInstance_p->PORT[0].CORE.MAC_PPS0_WIDTH.U = GETH_PORT0_MAC_PPS0_WIDTH;

    gethInstance_p->PORT[0].CORE.MAC_PPS_CONTROL.U = GETH_PORT0_MAC_PPS_CONTROL;

    IfxPort_setPinModeOutput(GETH_PORT0_MAC_PPS0_PIN.pin.port, GETH_PORT0_MAC_PPS0_PIN.pin.pinIndex, IfxPort_OutputMode_pushPull, GETH_PORT0_MAC_PPS0_PIN.select);

    gethInstance_p->PORT[0].CORE.MAC_FPE_CTRL_STS.U = GETH_PORT0_MAC_FPE_CTRL_STS;
    gethInstance_p->PORT[0].MTL.FPE_CTRL_STS.U = GETH_PORT0_MTL_FPE_CTRL_STS;
    gethInstance_p->PORT[0].MTL.FPE_ADVANCE.U = GETH_PORT0_MTL_FPE_ADVANCE;

#if (GETH_PORT0_MTL_EST_CONTROL == (1 << IFX_GETH_PORT_MTL_EST_CONTROL_EEST_OFF))
    Geth_Mac_writeGcl(GETH_MAC0, 1, GETH_MAC_GCL_BTR_LOW_ADDR, GETH_PORT0_MTL_EST_GCL_BTR_NSEC);
    Geth_Mac_writeGcl(GETH_MAC0, 1, GETH_MAC_GCL_BTR_HIGH_ADDR, GETH_PORT0_MTL_EST_GCL_BTR_SEC);
    Geth_Mac_writeGcl(GETH_MAC0, 1, GETH_MAC_GCL_CTR_LOW_ADDR, GETH_PORT0_MTL_EST_GCL_CTR_NSEC);
    Geth_Mac_writeGcl(GETH_MAC0, 1, GETH_MAC_GCL_CTR_HIGH_ADDR, 0);
    Geth_Mac_writeGcl(GETH_MAC0, 1, GETH_MAC_GCL_LLR_ADDR, GETH_PORT0_MTL_EST_GCL_LLR);

    for (uint8 i = 0; i < GETH_PORT0_MTL_EST_GCL_LLR; i++)
    {
        Geth_Mac_writeGcl(GETH_MAC0, 0, i, GETH_PORT0_MTL_EST_GCL_DATA[i]);
    }

    MODULE_GETH0.PORT[0].MTL.EST_CONTROL.U = GETH_PORT0_MTL_EST_CONTROL;
#endif

#if ((GETH_PORT0_MAC_INTERRUPT_ENABLE != 0) || (GETH_PORT0_MTL_EST_INTR_ENABLE != 0) || (GETH_PORT0_MAC_PCTH_INTR_ENABLE != 0))
    if (g_gethMac.irqInitDone_u8 == 0)
    {
        Geth_Mac_enableServiceRequest(GETH_PORTn_MAC_INT_TOS, GETH_PORTn_MAC_INT_PRIO);
        g_gethMac.irqInitDone_u8 = 1;
    }
#endif /* (GETH_PORT0_MAC_INTERRUPT_ENABLE != 0) */

    gethInstance_p->PORT[0].CORE.MAC_PCTH_INTR_ENABLE.U = GETH_PORT0_MAC_PCTH_INTR_ENABLE;

    gethInstance_p->PORT[0].CORE.MAC_INTERRUPT_ENABLE.U = GETH_PORT0_MAC_INTERRUPT_ENABLE;

    g_mac0Initialized_b = TRUE;
    return SUCCESS;
#else
    return FAILURE;
#endif /* IFX_SOLUTION_DESIGNER_GETH_ENABLE */
}

sint32 Geth_Mac1_Init(void)
{
    Ifx_GETH* gethInstance_p;

    if (g_gethMac.initDone_u8 == 0)
    {
        return FAILURE;
    }

    if (g_mac1Initialized_b == TRUE)
    {
        return SUCCESS;
    }

    gethInstance_p = g_gethMac.gethInstance_p;

#ifdef IFX_SOLUTION_DESIGNER_GETH_ENABLE
    gethInstance_p->PORT[1].MTL.ECC_CONTROL.U = GETH_PORT1_MTL_ECC_CONTROL;
    gethInstance_p->PORT[1].CORE.MAC_EXTENDED_CONFIGURATION.U = GETH_PORT1_MAC_EXTENDED_CONFIGURATION;
    gethInstance_p->PORT[1].CORE.MAC_TX_CONFIGURATION.U = GETH_PORT1_MAC_TX_CONFIGURATION;
    gethInstance_p->PORT[1].CORE.MAC_RX_CONFIGURATION.U = GETH_PORT1_MAC_RX_CONFIGURATION;
    gethInstance_p->PORT[1].MTL.OPERATION_MODE.U = GETH_PORT1_MTL_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.RXQ_DMA_MAP0.U = GETH_PORT1_MTL_RXQ_DMA_MAP0;
    gethInstance_p->PORT[1].MTL.RXQ_DMA_MAP1.U = GETH_PORT1_MTL_RXQ_DMA_MAP1;
    gethInstance_p->PORT[1].MTL.TCQ0.TC0_QUANTUM_WEIGHT.U = GETH_PORT1_MTL_TC0_QUANTUM_WEIGHT;
    gethInstance_p->PORT[1].MTL.TCQ1.TC1_QUANTUM_WEIGHT.U = GETH_PORT1_MTL_TC1_QUANTUM_WEIGHT;
    gethInstance_p->PORT[1].MTL.TCQ2.TC2_QUANTUM_WEIGHT.U = GETH_PORT1_MTL_TC2_QUANTUM_WEIGHT;
    gethInstance_p->PORT[1].MTL.TCQ3.TC3_QUANTUM_WEIGHT.U = GETH_PORT1_MTL_TC3_QUANTUM_WEIGHT;
    gethInstance_p->PORT[1].MTL.TCQ4.TC4_QUANTUM_WEIGHT.U = GETH_PORT1_MTL_TC4_QUANTUM_WEIGHT;
    gethInstance_p->PORT[1].MTL.TCQ5.TC5_QUANTUM_WEIGHT.U = GETH_PORT1_MTL_TC5_QUANTUM_WEIGHT;
    gethInstance_p->PORT[1].MTL.TCQ6.TC6_QUANTUM_WEIGHT.U = GETH_PORT1_MTL_TC6_QUANTUM_WEIGHT;
    gethInstance_p->PORT[1].MTL.TCQ7.TC7_QUANTUM_WEIGHT.U = GETH_PORT1_MTL_TC7_QUANTUM_WEIGHT;
    gethInstance_p->PORT[1].MTL.TCQ0.TC0_ETS_CONTROL.U = GETH_PORT1_MTL_TC0_ETS_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ1.TC1_ETS_CONTROL.U = GETH_PORT1_MTL_TC1_ETS_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ2.TC2_ETS_CONTROL.U = GETH_PORT1_MTL_TC2_ETS_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ3.TC3_ETS_CONTROL.U = GETH_PORT1_MTL_TC3_ETS_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ4.TC4_ETS_CONTROL.U = GETH_PORT1_MTL_TC4_ETS_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ5.TC5_ETS_CONTROL.U = GETH_PORT1_MTL_TC5_ETS_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ6.TC6_ETS_CONTROL.U = GETH_PORT1_MTL_TC6_ETS_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ7.TC7_ETS_CONTROL.U = GETH_PORT1_MTL_TC7_ETS_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ5.TC5_HICREDIT.U = GETH_PORT1_MTL_TC5_HICREDIT;
    gethInstance_p->PORT[1].MTL.TCQ6.TC6_HICREDIT.U = GETH_PORT1_MTL_TC6_HICREDIT;
    gethInstance_p->PORT[1].MTL.TCQ7.TC7_HICREDIT.U = GETH_PORT1_MTL_TC7_HICREDIT;
    gethInstance_p->PORT[1].MTL.TCQ5.TC5_LOCREDIT.U = GETH_PORT1_MTL_TC5_LOCREDIT;
    gethInstance_p->PORT[1].MTL.TCQ6.TC6_LOCREDIT.U = GETH_PORT1_MTL_TC6_LOCREDIT;
    gethInstance_p->PORT[1].MTL.TCQ7.TC7_LOCREDIT.U = GETH_PORT1_MTL_TC7_LOCREDIT;
    gethInstance_p->PORT[1].MTL.TCQ5.TC5_SENDSLOPECREDIT.U = GETH_PORT1_MTL_TC5_SENDSLOPECREDIT;
    gethInstance_p->PORT[1].MTL.TCQ6.TC6_SENDSLOPECREDIT.U = GETH_PORT1_MTL_TC6_SENDSLOPECREDIT;
    gethInstance_p->PORT[1].MTL.TCQ7.TC7_SENDSLOPECREDIT.U = GETH_PORT1_MTL_TC7_SENDSLOPECREDIT;
    gethInstance_p->PORT[1].MTL.TCQ0.TXQ0_OPERATION_MODE.U = GETH_PORT1_MTL_TXQ0_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ1.TXQ1_OPERATION_MODE.U = GETH_PORT1_MTL_TXQ1_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ2.TXQ2_OPERATION_MODE.U = GETH_PORT1_MTL_TXQ2_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ3.TXQ3_OPERATION_MODE.U = GETH_PORT1_MTL_TXQ3_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ4.TXQ4_OPERATION_MODE.U = GETH_PORT1_MTL_TXQ4_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ5.TXQ5_OPERATION_MODE.U = GETH_PORT1_MTL_TXQ5_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ6.TXQ6_OPERATION_MODE.U = GETH_PORT1_MTL_TXQ6_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ7.TXQ7_OPERATION_MODE.U = GETH_PORT1_MTL_TXQ7_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ0.RXQ0_OPERATION_MODE.U = GETH_PORT1_MTL_RXQ0_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ1.RXQ1_OPERATION_MODE.U = GETH_PORT1_MTL_RXQ1_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ2.RXQ2_OPERATION_MODE.U = GETH_PORT1_MTL_RXQ2_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ3.RXQ3_OPERATION_MODE.U = GETH_PORT1_MTL_RXQ3_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ4.RXQ4_OPERATION_MODE.U = GETH_PORT1_MTL_RXQ4_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ5.RXQ5_OPERATION_MODE.U = GETH_PORT1_MTL_RXQ5_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ6.RXQ6_OPERATION_MODE.U = GETH_PORT1_MTL_RXQ6_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ7.RXQ7_OPERATION_MODE.U = GETH_PORT1_MTL_RXQ7_OPERATION_MODE;
    gethInstance_p->PORT[1].MTL.TCQ0.RXQ0_CONTROL.U = GETH_PORT1_MTL_RXQ0_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ1.RXQ1_CONTROL.U = GETH_PORT1_MTL_RXQ1_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ2.RXQ2_CONTROL.U = GETH_PORT1_MTL_RXQ2_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ3.RXQ3_CONTROL.U = GETH_PORT1_MTL_RXQ3_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ4.RXQ4_CONTROL.U = GETH_PORT1_MTL_RXQ4_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ5.RXQ5_CONTROL.U = GETH_PORT1_MTL_RXQ5_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ6.RXQ6_CONTROL.U = GETH_PORT1_MTL_RXQ6_CONTROL;
    gethInstance_p->PORT[1].MTL.TCQ7.RXQ7_CONTROL.U = GETH_PORT1_MTL_RXQ7_CONTROL;
    gethInstance_p->PORT[1].CORE.MAC_RXQ_CTRL0.U = GETH_PORT1_MAC_RXQ_CTRL0;
    gethInstance_p->PORT[1].CORE.MAC_RXQ_CTRL1.U = GETH_PORT1_MAC_RXQ_CTRL1;
    gethInstance_p->PORT[1].CORE.MAC_RXQ_CTRL2.U = GETH_PORT1_MAC_RXQ_CTRL2;
    gethInstance_p->PORT[1].CORE.MAC_RXQ_CTRL3.U = GETH_PORT1_MAC_RXQ_CTRL3;
    gethInstance_p->PORT[1].CORE.MAC_RXQ_CTRL4.U = GETH_PORT1_MAC_RXQ_CTRL4;
    gethInstance_p->PORT[1].CORE.MACADDRESS0.HIGH.U = GETH_PORT1_MAC_ADDRESS0_HIGH;
    gethInstance_p->PORT[1].CORE.MACADDRESS0.LOW.U =  GETH_PORT1_MAC_ADDRESS0_LOW;
    gethInstance_p->PORT[1].CORE.MACADDRESS1.HIGH.U = GETH_PORT1_MAC_ADDRESS1_HIGH;
    gethInstance_p->PORT[1].CORE.MACADDRESS1.LOW.U =  GETH_PORT1_MAC_ADDRESS1_LOW;
    gethInstance_p->PORT[1].CORE.MACADDRESS2.HIGH.U = GETH_PORT1_MAC_ADDRESS2_HIGH;
    gethInstance_p->PORT[1].CORE.MACADDRESS2.LOW.U =  GETH_PORT1_MAC_ADDRESS2_LOW;
    gethInstance_p->PORT[1].CORE.MACADDRESS3.HIGH.U = GETH_PORT1_MAC_ADDRESS3_HIGH;
    gethInstance_p->PORT[1].CORE.MACADDRESS3.LOW.U =  GETH_PORT1_MAC_ADDRESS3_LOW;
    gethInstance_p->PORT[1].CORE.MACADDRESS4.HIGH.U = GETH_PORT1_MAC_ADDRESS4_HIGH;
    gethInstance_p->PORT[1].CORE.MACADDRESS4.LOW.U =  GETH_PORT1_MAC_ADDRESS4_LOW;
    gethInstance_p->PORT[1].CORE.MACADDRESS5.HIGH.U = GETH_PORT1_MAC_ADDRESS5_HIGH;
    gethInstance_p->PORT[1].CORE.MACADDRESS5.LOW.U =  GETH_PORT1_MAC_ADDRESS5_LOW;
    gethInstance_p->PORT[1].CORE.MACADDRESS6.HIGH.U = GETH_PORT1_MAC_ADDRESS6_HIGH;
    gethInstance_p->PORT[1].CORE.MACADDRESS6.LOW.U =  GETH_PORT1_MAC_ADDRESS6_LOW;
    gethInstance_p->PORT[1].CORE.MACADDRESS7.HIGH.U = GETH_PORT1_MAC_ADDRESS7_HIGH;
    gethInstance_p->PORT[1].CORE.MACADDRESS7.LOW.U =  GETH_PORT1_MAC_ADDRESS7_LOW;
    gethInstance_p->PORT[1].CORE.MACADDRESS8.HIGH.U = GETH_PORT0_MAC_ADDRESS8_HIGH;
    gethInstance_p->PORT[1].CORE.MACADDRESS8.LOW.U =  GETH_PORT0_MAC_ADDRESS8_LOW;

    Geth_Mac_DmaSel_Write(GETH_MAC1, 0, GETH_PORT1_MAC_DCHSEL_INDREG0);
    Geth_Mac_DmaSel_Write(GETH_MAC1, 1, GETH_PORT1_MAC_DCHSEL_INDREG1);
    Geth_Mac_DmaSel_Write(GETH_MAC1, 2, GETH_PORT1_MAC_DCHSEL_INDREG2);
    Geth_Mac_DmaSel_Write(GETH_MAC1, 3, GETH_PORT1_MAC_DCHSEL_INDREG3);
    Geth_Mac_DmaSel_Write(GETH_MAC1, 4, GETH_PORT1_MAC_DCHSEL_INDREG4);
    Geth_Mac_DmaSel_Write(GETH_MAC1, 5, GETH_PORT1_MAC_DCHSEL_INDREG5);
    Geth_Mac_DmaSel_Write(GETH_MAC1, 6, GETH_PORT1_MAC_DCHSEL_INDREG6);
    Geth_Mac_DmaSel_Write(GETH_MAC1, 7, GETH_PORT1_MAC_DCHSEL_INDREG7);
    Geth_Mac_DmaSel_Write(GETH_MAC1, 8, GETH_PORT1_MAC_DCHSEL_INDREG8);
    Geth_Mac_DmaSel_Write(GETH_MAC1, 9, GETH_PORT1_MAC_DCHSEL_INDREG9);

    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 0, GETH_PORT1_MAC_DPCSEL_INDREG0);
    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 1, GETH_PORT1_MAC_DPCSEL_INDREG1);
    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 2, GETH_PORT1_MAC_DPCSEL_INDREG2);
    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 3, GETH_PORT1_MAC_DPCSEL_INDREG3);
    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 4, GETH_PORT1_MAC_DPCSEL_INDREG4);
    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 5, GETH_PORT1_MAC_DPCSEL_INDREG5);
    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 6, GETH_PORT1_MAC_DPCSEL_INDREG6);
    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 7, GETH_PORT1_MAC_DPCSEL_INDREG7);
    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 8, GETH_PORT1_MAC_DPCSEL_INDREG8);
    Geth_Mac_DstSrcPlcySel_Write(GETH_MAC1, 9, GETH_PORT1_MAC_DPCSEL_INDREG9);
    Geth_Mac_FailPlcySel_Write(GETH_MAC1, 0, GETH_PORT1_MAC_FPCSEL_INDREG0);

    Geth_Mac_PolicyCounterCtrl_Write(GETH_MAC1, 0, GETH_PORT1_MAC_PCCTRL_INDREG0);
    Geth_Mac_PolicyCounterCtrl_Write(GETH_MAC1, 1, GETH_PORT1_MAC_PCCTRL_INDREG1);
    Geth_Mac_PolicyCounterCtrl_Write(GETH_MAC1, 2, GETH_PORT1_MAC_PCCTRL_INDREG2);
    Geth_Mac_PolicyCounterCtrl_Write(GETH_MAC1, 3, GETH_PORT1_MAC_PCCTRL_INDREG3);
    Geth_Mac_PolicyCounterCtrl_Write(GETH_MAC1, 4, GETH_PORT1_MAC_PCCTRL_INDREG4);
    Geth_Mac_PolicyCounterCtrl_Write(GETH_MAC1, 5, GETH_PORT1_MAC_PCCTRL_INDREG5);
    Geth_Mac_PolicyCounterCtrl_Write(GETH_MAC1, 6, GETH_PORT1_MAC_PCCTRL_INDREG6);
    Geth_Mac_PolicyCounterCtrl_Write(GETH_MAC1, 7, GETH_PORT1_MAC_PCCTRL_INDREG7);

    gethInstance_p->PORT[1].CORE.MAC_VLAN_TAG_CTRL.U = GETH_PORT1_MAC_VLAN_TAG_CTRL;
    gethInstance_p->PORT[1].CORE.MAC_INNER_VLAN_INCL.U = GETH_PORT1_MAC_INNER_VLAN_INCL;
    Geth_Mac_Vlan_Incl_Write(GETH_MAC1, GETH_MAC_QUEUE0, GETH_PORT1_MAC_VLAN_INCL, GETH_PORT1_MAC_VLAN_INCL0);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC1, GETH_MAC_QUEUE1, GETH_PORT1_MAC_VLAN_INCL, GETH_PORT1_MAC_VLAN_INCL1);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC1, GETH_MAC_QUEUE2, GETH_PORT1_MAC_VLAN_INCL, GETH_PORT1_MAC_VLAN_INCL2);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC1, GETH_MAC_QUEUE3, GETH_PORT1_MAC_VLAN_INCL, GETH_PORT1_MAC_VLAN_INCL3);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC1, GETH_MAC_QUEUE4, GETH_PORT1_MAC_VLAN_INCL, GETH_PORT1_MAC_VLAN_INCL4);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC1, GETH_MAC_QUEUE5, GETH_PORT1_MAC_VLAN_INCL, GETH_PORT1_MAC_VLAN_INCL5);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC1, GETH_MAC_QUEUE6, GETH_PORT1_MAC_VLAN_INCL, GETH_PORT1_MAC_VLAN_INCL6);
    Geth_Mac_Vlan_Incl_Write(GETH_MAC1, GETH_MAC_QUEUE7, GETH_PORT1_MAC_VLAN_INCL, GETH_PORT1_MAC_VLAN_INCL7);
    gethInstance_p->PORT[1].CORE.MAC_PACKET_FILTER.U = GETH_PORT1_MAC_PACKET_FILTER;

#if 1
    Geth_Mac_Vlan_Filter_Write(GETH_MAC1, GETH_MAC_QUEUE0, GETH_PORT1_MAC_VLAN_TAG_FILTER0);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC1, GETH_MAC_QUEUE1, GETH_PORT1_MAC_VLAN_TAG_FILTER1);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC1, GETH_MAC_QUEUE2, GETH_PORT1_MAC_VLAN_TAG_FILTER2);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC1, GETH_MAC_QUEUE3, GETH_PORT1_MAC_VLAN_TAG_FILTER3);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC1, GETH_MAC_QUEUE4, GETH_PORT1_MAC_VLAN_TAG_FILTER4);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC1, GETH_MAC_QUEUE5, GETH_PORT1_MAC_VLAN_TAG_FILTER5);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC1, GETH_MAC_QUEUE6, GETH_PORT1_MAC_VLAN_TAG_FILTER6);
    Geth_Mac_Vlan_Filter_Write(GETH_MAC1, GETH_MAC_QUEUE7, GETH_PORT1_MAC_VLAN_TAG_FILTER7);
#endif
    /* 2. enable time stamping */
    gethInstance_p->PORT[1].CORE.MAC_TIMESTAMP_CONTROL.U = GETH_PORT1_MAC_TIMESTAMP_CONTROL;
    /* 3. Program sub second increment based on PTP frequency */
    gethInstance_p->PORT[1].CORE.MAC_SUB_SECOND_INCREMENT.B.SSINC =  (uint32)1E9 / GETH_PORT1_MAC_TIMESTAMP_FPTP;
    gethInstance_p->PORT[1].CORE.MAC_SUB_SECOND_INCREMENT.B.SNSINC = (((double)1E9 / (double)GETH_PORT1_MAC_TIMESTAMP_FPTP) - (uint32)(1E9 / GETH_PORT1_MAC_TIMESTAMP_FPTP)) * 256;
    /* 2^32 / fGETH / fPTP */
    gethInstance_p->PORT[1].CORE.MAC_TIMESTAMP_ADDEND.B.TSAR = (uint32)((double)(1ull << 32u) / (double)(IfxClock_getXGeth0Frequency() / (float32)GETH_PORT1_MAC_TIMESTAMP_FPTP));
    /* 4. optional, start updating the time stamp addend register to the PTP clock */
    gethInstance_p->PORT[1].CORE.MAC_TIMESTAMP_CONTROL.B.TSADDREG = 1u;
    /* 5. optionally, wait until the update is done */
    while (gethInstance_p->PORT[1].CORE.MAC_TIMESTAMP_CONTROL.B.TSADDREG == 1u) {}
    /* 6. optional, set Fine or Coarse time stamp Update */
    gethInstance_p->PORT[1].CORE.MAC_TIMESTAMP_CONTROL.B.TSCFUPDT = 1u;
    /* 7. Program MAC_System_Time_Seconds_Update Register and MAC_System_Time_Nanoseconds_Update */
    gethInstance_p->PORT[1].CORE.MAC_SYSTEM_TIME_SECONDS_UPDATE.U = 0u;
    gethInstance_p->PORT[1].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.U = 0u;
    /* 8. Initialize time stamp */
    gethInstance_p->PORT[1].CORE.MAC_TIMESTAMP_CONTROL.B.TSINIT = 1u;

    gethInstance_p->PORT[1].CORE.MAC_PPS0_TARGET_TIME_SECONDS.U = GETH_PORT1_MAC_PPS0_TARGET_TIME_SECONDS;
    gethInstance_p->PORT[1].CORE.MAC_PPS0_TARGET_TIME_NANOSECONDS.U = GETH_PORT1_MAC_PPS0_TARGET_TIME_NANOSECONDS;
    while (gethInstance_p->PORT[1].CORE.MAC_PPS0_TARGET_TIME_NANOSECONDS.B.TRGTBUSY0 == 1) {}

    gethInstance_p->PORT[1].CORE.MAC_PPS0_INTERVAL.U = GETH_PORT1_MAC_PPS0_INTERVAL;
    gethInstance_p->PORT[1].CORE.MAC_PPS0_WIDTH.U = GETH_PORT1_MAC_PPS0_WIDTH;

    gethInstance_p->PORT[1].CORE.MAC_PPS_CONTROL.U = GETH_PORT1_MAC_PPS_CONTROL;

    IfxPort_setPinModeOutput(GETH_PORT1_MAC_PPS0_PIN.pin.port, GETH_PORT1_MAC_PPS0_PIN.pin.pinIndex, IfxPort_OutputMode_pushPull, GETH_PORT1_MAC_PPS0_PIN.select);

    gethInstance_p->PORT[1].CORE.MAC_FPE_CTRL_STS.U = GETH_PORT1_MAC_FPE_CTRL_STS;
    gethInstance_p->PORT[1].MTL.FPE_CTRL_STS.U = GETH_PORT1_MTL_FPE_CTRL_STS;
    gethInstance_p->PORT[1].MTL.FPE_ADVANCE.U = GETH_PORT1_MTL_FPE_ADVANCE;

#if (GETH_PORT1_MTL_EST_CONTROL == (1 << IFX_GETH_PORT_MTL_EST_CONTROL_EEST_OFF))
    Geth_Mac_writeGcl(GETH_MAC1, 1, GETH_MAC_GCL_BTR_LOW_ADDR, GETH_PORT1_MTL_EST_GCL_BTR_NSEC);
    Geth_Mac_writeGcl(GETH_MAC1, 1, GETH_MAC_GCL_BTR_HIGH_ADDR, GETH_PORT1_MTL_EST_GCL_BTR_SEC);
    Geth_Mac_writeGcl(GETH_MAC1, 1, GETH_MAC_GCL_CTR_LOW_ADDR, GETH_PORT1_MTL_EST_GCL_CTR_NSEC);
    Geth_Mac_writeGcl(GETH_MAC1, 1, GETH_MAC_GCL_CTR_HIGH_ADDR, 0);
    Geth_Mac_writeGcl(GETH_MAC1, 1, GETH_MAC_GCL_LLR_ADDR, GETH_PORT1_MTL_EST_GCL_LLR);

    for (uint8 i = 0; i < GETH_PORT1_MTL_EST_GCL_LLR; i++)
    {
        Geth_Mac_writeGcl(GETH_MAC1, 0, i, GETH_PORT1_MTL_EST_GCL_DATA[i]);
    }

    MODULE_GETH0.PORT[1].MTL.EST_CONTROL.U = GETH_PORT1_MTL_EST_CONTROL;
#endif

#if ((GETH_PORT1_MAC_INTERRUPT_ENABLE != 0) || (GETH_PORT1_MTL_EST_INTR_ENABLE != 0) || (GETH_PORT1_MAC_PCTH_INTR_ENABLE != 0))
    if (g_gethMac.irqInitDone_u8 == 0)
    {
        Geth_Mac_enableServiceRequest(GETH_PORTn_MAC_INT_TOS, GETH_PORTn_MAC_INT_PRIO);
        g_gethMac.irqInitDone_u8 = 1;
    }
#endif /* (GETH_PORT1_MAC_INTERRUPT_ENABLE != 0) */
    gethInstance_p->PORT[1].CORE.MAC_PCTH_INTR_ENABLE.U = GETH_PORT1_MAC_PCTH_INTR_ENABLE;

    gethInstance_p->PORT[1].CORE.MAC_INTERRUPT_ENABLE.U = GETH_PORT1_MAC_INTERRUPT_ENABLE;

    g_mac1Initialized_b = TRUE;
    return SUCCESS;
#else
    return FAILURE;
#endif /* IFX_SOLUTION_DESIGNER_GETH_ENABLE */
}

#if ((GETH_PORT0_MAC_INTERRUPT_ENABLE != 0) || (GETH_PORT1_MAC_INTERRUPT_ENABLE != 0) || (GETH_PORT0_MTL_EST_INTR_ENABLE != 0) || (GETH_PORT0_MAC_PCTH_INTR_ENABLE != 0))
    IFX_INTERRUPT(GETH0_MAC_ISR, GETH_PORTn_MAC_INT_TOS, GETH_PORTn_MAC_INT_PRIO)
    {
        #if ((GETH_PORT0_MAC_PCTH_INTR_ENABLE & 1) != 0)
            if ((g_gethMac.gethInstance_p->PORT[0].CORE.MAC_PCTH_INTR_STATUS.U & 1) != 0)
            {
                GETH_PORT0_MAC_PCTH_INTR_ENABLE_ISR0();
            }
        #endif

        #if ((GETH_PORT0_MTL_EST_INTR_ENABLE & (IFX_GETH_PORT_MTL_EST_INTR_ENABLE_IECC_MSK << IFX_GETH_PORT_MTL_EST_INTR_ENABLE_IECC_OFF)) != 0)
            if (g_gethMac.gethInstance_p->PORT[0].MTL.EST_STATUS.B.SWLC == 1u)
            {
                GETH_PORT0_MTL_EST_INTR_ENABLE_IECC_ISR();
            }
        #endif
            if (g_gethMac.gethInstance_p->PORT[0].CORE.MAC_INTERRUPT_STATUS.B.TSIS == 1u)
            {
#if (GETH_PORT0_MAC_INTERRUPT_ENABLE_TSCAPTURED == 1)
                if (g_gethMac.gethInstance_p->PORT[0].CORE.MAC_TIMESTAMP_STATUS.B.TXTSC == 1u)
                {
                    GETH_PORT0_MAC_INTERRUPT_ENABLE_TSCAPTURED_ISR();
                }
#endif /* (GETH_PORT0_MAC_INTERRUPT_ENABLE_TSCAPTURED == 1) */
#if (GETH_PORT0_MAC_INTERRUPT_ENABLE_TGTTIMEREACHED == 1)
                if (g_gethMac.gethInstance_p->PORT[0].CORE.MAC_TIMESTAMP_STATUS.B.TSTARGT0 == 1u)
                {
                    GETH_PORT0_MAC_INTERRUPT_ENABLE_TGTTIMEREACHED_ISR();
                }
#endif /* (GETH_PORT0_MAC_INTERRUPT_ENABLE_TGTTIMEREACHED == 1) */
            }
        #if ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_OFF)) != 0)
            if (g_gethMac.gethInstance_p->PORT[1].CORE.MAC_INTERRUPT_STATUS.B.TSIS == 1u)
            {
                if (g_gethMac.gethInstance_p->PORT[1].CORE.MAC_TIMESTAMP_STATUS.B.TXTSC == 1u)
                {
                    GETH_PORT1_MAC_INTERRUPT_ENABLE_TSIE_ISR();
                }
            }
        #endif /* ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TSIE_OFF)) != 0) */
        #if ((GETH_PORT0_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_OFF)) != 0)
            if (g_gethMac.gethInstance_p->PORT[0].CORE.MAC_INTERRUPT_STATUS.B.TXESIS == 1u)
            {
                GETH_PORT0_MAC_INTERRUPT_ENABLE_TXESIS_ISR();
            }
        #endif /* ((GETH_PORT0_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_OFF)) != 0) */
        #if ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_OFF)) != 0)
            if (g_gethMac.gethInstance_p->PORT[1].CORE.MAC_INTERRUPT_STATUS.B.TXESIS == 1u)
            {
                GETH_PORT1_MAC_INTERRUPT_ENABLE_TXESIS_ISR();
            }
        #endif /* ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_TXESIE_OFF)) != 0) */
        #if ((GETH_PORT0_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_OFF)) != 0)
            if (g_gethMac.gethInstance_p->PORT[0].CORE.MAC_INTERRUPT_STATUS.B.RXESIS == 1u)
            {
                GETH_PORT0_MAC_INTERRUPT_ENABLE_RXESIS_ISR();
            }
        #endif /* ((GETH_PORT0_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_OFF)) != 0) */
        #if ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_OFF)) != 0)
            if (g_gethMac.gethInstance_p->PORT[1].CORE.MAC_INTERRUPT_STATUS.B.RXESIS == 1u)
            {
                GETH_PORT1_MAC_INTERRUPT_ENABLE_RXESIS_ISR();
            }
        #endif /* ((GETH_PORT1_MAC_INTERRUPT_ENABLE & (IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_MSK << IFX_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE_RXESIE_OFF)) != 0) */
    }
#endif /* (GETH_PORT0_MAC_INTERRUPT_ENABLE != 0) */

#ifdef IFX_SOLUTION_DESIGNER_GETH_ENABLE
#if 0
sint32 Geth_Mac_Vlan_Incl_Write(const uint8 gethPort_u8, const uint8 regIdx_u8, const uint32 vlanInclValue_u32)
{
    //Ifx_GETH_PORT_CORE_MAC_VLAN_INCL vlan_incl;
    uint32s *pAddr;
    uint32s vlan_incl;

    uint32 ui;

    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (regIdx_u8 >= 8))
    {
      return FAILURE;
    }

    //pAddr = (uint8*)&g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U;

    ui = vlanInclValue_u32 >> IFX_GETH_PORT_CORE_MAC_VLAN_INCL_CBTI_OFF;
    ui &= IFX_GETH_PORT_CORE_MAC_VLAN_INCL_CBTI_MSK;

//    if ((vlanInclValue_u32 >> IFX_GETH_PORT_CORE_MAC_VLAN_INCL_CBTI_OFF) & IFX_GETH_PORT_CORE_MAC_VLAN_INCL_CBTI_MSK == 0)
    if (ui == 0)
    {
        return FAILURE;
    }

    vlan_incl.dword = vlanInclValue_u32;

    pAddr = (uint32s*)&g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U;
    pAddr->byte[2] = 0x20;
    pAddr->byte[3] = vlan_incl.byte[3] | 0x40 | (regIdx_u8 & 0x7);
    pAddr->byte[2] = vlan_incl.byte[2] | 0x20;
    pAddr->byte[1] = vlan_incl.byte[1];
    pAddr->byte[0] = vlan_incl.byte[0];

    //g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.CBTI = 1;
    //g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.ADDR = regIdx_u8;
    //g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.RDWR = 1u;

//    vlan_incl.U = vlanInclValue_u32;

//    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.CSVL = vlan_incl.B.CSVL;
//    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.VLC = vlan_incl.B.VLC;
//    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.VLP = vlan_incl.B.VLP;
//    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.VLTI = vlan_incl.B.VLTI;
//    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.VLT = vlan_incl.B.VLT;

    while (g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.BUSY == 1u) {}

    printf("VLAN_Incl_write[%i] = %08x"EOL, (int)regIdx_u8, (int)g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U);

    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.CBTI = 0;
//    pAddr->byte[2] = 0x0;

    return SUCCESS;
}
#endif
#if 1
sint32 Geth_Mac_Vlan_Incl_Write(const uint8 gethPort_u8, const uint8 regIdx_u8, const uint32 globalVlanInclValue_u32, const uint32 localVlanInclValue_u32)
{
    volatile Ifx_GETH_PORT_CORE_MAC_VLAN_INCL vlan_incl;
    uint8 *pAddr;

    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (regIdx_u8 >= 8))
    {
      return FAILURE;
    }

    pAddr = (uint8*)&g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U;

    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.CBTI = 1;

    vlan_incl.U = localVlanInclValue_u32;
    /* 1: write access, 0 : read access */
    vlan_incl.B.RDWR = 1u;
    vlan_incl.B.ADDR = regIdx_u8;
    vlan_incl.B.CBTI = 1;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U = vlan_incl.U;
    while (g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.BUSY == 1u) {}

    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U = globalVlanInclValue_u32;

    return SUCCESS;
}
#endif
#if 0
sint32 Geth_Mac_Vlan_Incl_Read(const uint8 gethPort_u8, const uint8 regIdx_u8, uint32 *const regValue_p)
{
    //Ifx_GETH_PORT_CORE_MAC_VLAN_INCL vlan_incl;
    //uint8 *pAddr;

    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (regIdx_u8 >= 8))
    {
      return FAILURE;
    }

    //pAddr = (uint8*)&g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U;

    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.CBTI = 1;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.RDWR = 0u;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.ADDR = regIdx_u8;

//    vlan_incl.U = g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U;
    /* 1: write access, 0 : read access */
//    vlan_incl.B.RDWR = 0u;
//    vlan_incl.B.ADDR = regIdx_u8;
    //vlan_incl.B.CBTI = 1;
//    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U = vlan_incl.U;
    while (g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.BUSY == 1u) {}

    *regValue_p = g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U;

    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.CBTI = 0;

    return SUCCESS;
}
#endif
sint32 Geth_Mac_Vlan_Incl_Read(const uint8 gethPort_u8, const uint8 regIdx_u8, uint32 *const regValue_p)
{
    Ifx_GETH_PORT_CORE_MAC_VLAN_INCL vlan_incl;
    //uint8 *pAddr;

    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (regIdx_u8 >= 8))
    {
      return FAILURE;
    }

    //pAddr = (uint8*)&g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U;

//    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.ADDR = regIdx_u8;
//    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.RDWR = 0u;
//    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.CBTI = 1;

    vlan_incl.U = GETH_PORT0_MAC_VLAN_INCL;//g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U;
    /* 1: write access, 0 : read access */
    vlan_incl.B.RDWR = 0u;
    vlan_incl.B.ADDR = regIdx_u8;
    vlan_incl.B.CBTI = 1;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.CBTI = 1;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U = vlan_incl.U;
    while (g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.BUSY == 1u) {}

    *regValue_p = g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.U;

    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_INCL.B.CBTI = 0;

    return SUCCESS;
}


sint32 Geth_Mac_Vlan_Filter_Write(const uint8 gethPort_u8, const uint8 vlanFiltIdx_u8, const uint32 vlanFiltValue_u32)
{
    Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL vlan_ctrl;
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (vlanFiltIdx_u8 >= 8u))
    {
      return FAILURE;
    }

    if (gethPort_u8 == 0u)
    {
        vlan_ctrl.U = GETH_PORT0_MAC_VLAN_TAG_CTRL;
    }
    else
    {
        vlan_ctrl.U = GETH_PORT1_MAC_VLAN_TAG_CTRL;
    }
    vlan_ctrl.B.OFS = vlanFiltIdx_u8;
    vlan_ctrl.B.CT = 0u; /* 0 = write, 1 = read */
    vlan_ctrl.B.OB = 1u; /* start write operation */
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_TAG_DATA.U = vlanFiltValue_u32;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_TAG_CTRL.U = vlan_ctrl.U;
    while (g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_VLAN_TAG_CTRL.B.OB == 1u) {}
    return SUCCESS;
}
#endif /* IFX_SOLUTION_DESIGNER_GETH_ENABLE */

sint32 Geth_Mac_DmaSel_Write(const uint8 gethPort_u8, const uint8 filtIdx_u8, const uint32 regValue_u32)
{
    Ifx_GETH_PORT_CORE_MAC_INDIR_ACCESS_CTRL acc_ctrl;
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (filtIdx_u8 >= 32u))
    {
      return FAILURE;
    }

    acc_ctrl.B.COM = 0; /* 0: write, 1: read */
    acc_ctrl.B.AUTO = 0;
    acc_ctrl.B.MSEL = 0; /* 0 = DChSel */
    acc_ctrl.B.AOFF = filtIdx_u8;
    acc_ctrl.B.OB = 1;

    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_DATA.U = regValue_u32;
    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.U = acc_ctrl.U;

    while (MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.B.OB == 1) {}
    return SUCCESS;
}

sint32 Geth_Mac_L3L4_Filter_writeDword(const uint8 gethPort_u8, const uint8 filtIdx_u8, const ETH_MAC_L3L4_OPCODE_t opCode_t, const uint32 regValue_u32)
{
    Ifx_GETH_PORT_CORE_MAC_L3_L4_ADDRESS_CONTROL l3_l4_ctrl;
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (filtIdx_u8 >= 8))
    {
      return FAILURE;
    }

    l3_l4_ctrl.B.IDDR = (filtIdx_u8 << 4) | opCode_t;
    l3_l4_ctrl.B.TT = 0u; /* 0 = write, 1 = read */
    l3_l4_ctrl.B.XB = 1u; /* start write operation */
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_L3_L4_DATA.U = regValue_u32;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_L3_L4_ADDRESS_CONTROL.U = l3_l4_ctrl.U;
    while (g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_L3_L4_ADDRESS_CONTROL.B.XB == 1u) {}
    return SUCCESS;
}

sint32 Geth_Mac_L3L4_Filter_readDword(const uint8 gethPort_u8, const uint8 filtIdx_u8, const ETH_MAC_L3L4_OPCODE_t opCode_t, uint32 *const regValue_p)
{
    Ifx_GETH_PORT_CORE_MAC_L3_L4_ADDRESS_CONTROL l3_l4_ctrl;
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (filtIdx_u8 >= 8))
    {
      return FAILURE;
    }

    l3_l4_ctrl.B.IDDR = (filtIdx_u8 << 4) | opCode_t;
    l3_l4_ctrl.B.TT = 1u; /* 0 = write, 1 = read */
    l3_l4_ctrl.B.XB = 1u; /* start write operation */

    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_L3_L4_ADDRESS_CONTROL.U = l3_l4_ctrl.U;
    while (g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_L3_L4_ADDRESS_CONTROL.B.XB == 1u) {}

    *regValue_p = g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_L3_L4_DATA.U;

    return SUCCESS;
}

sint32 Geth_Mac_PolicyCounterCtrl_Write(const uint8 gethPort_u8, const uint8 pccIdx_u8, const uint32 regValue_u32)
{
    Ifx_GETH_PORT_CORE_MAC_INDIR_ACCESS_CTRL acc_ctrl;
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (pccIdx_u8 >= 32u))
    {
      return FAILURE;
    }

    acc_ctrl.B.COM = 0; /* 0: write, 1: read */
    acc_ctrl.B.AUTO = 0;
    acc_ctrl.B.MSEL = 1; /* 1 = PCCtrlSel */
    acc_ctrl.B.AOFF = pccIdx_u8;
    acc_ctrl.B.OB = 1;

    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_DATA.U = regValue_u32;
    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.U = acc_ctrl.U;

    while (MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.B.OB == 1) {}
    return SUCCESS;
}

sint32 Geth_Mac_PolicyCounter_Write(const uint8 gethPort_u8, const uint8 pcIdx_u8, const uint32 regValue_u32)
{
    Ifx_GETH_PORT_CORE_MAC_INDIR_ACCESS_CTRL acc_ctrl;
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (pcIdx_u8 >= 32u))
    {
      return FAILURE;
    }

    acc_ctrl.B.COM = 0; /* 0: write, 1: read */
    acc_ctrl.B.AUTO = 0;
    acc_ctrl.B.MSEL = 2; /* 2 = PCSel */
    acc_ctrl.B.AOFF = pcIdx_u8;
    acc_ctrl.B.OB = 1;

    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_DATA.U = regValue_u32;
    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.U = acc_ctrl.U;

    while (MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.B.OB == 1) {}
    return SUCCESS;
}

sint32 Geth_Mac_PolicyCounter_Read(const uint8 gethPort_u8, const uint8 pcIdx_u8, uint32 * const regValue_p)
{
    Ifx_GETH_PORT_CORE_MAC_INDIR_ACCESS_CTRL acc_ctrl;
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (regValue_p == NULL))
    {
      return FAILURE;
    }

    acc_ctrl.B.COM = 1; /* 0: write, 1: read */
    acc_ctrl.B.AUTO = 0;
    acc_ctrl.B.MSEL = 2; /* 2 = PCSel */
    acc_ctrl.B.AOFF = pcIdx_u8;
    acc_ctrl.B.OB = 1;

    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.U = acc_ctrl.U;

    while (MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.B.OB == 1) {}

    *regValue_p = MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_DATA.U;

    return SUCCESS;
}

sint32 Geth_Mac_DstSrcPlcySel_Write(const uint8 gethPort_u8, const uint8 daIdx_u8, const uint32 regValue_u32)
{
    Ifx_GETH_PORT_CORE_MAC_INDIR_ACCESS_CTRL acc_ctrl;
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (daIdx_u8 >= 32u))
    {
      return FAILURE;
    }

    acc_ctrl.B.COM = 0; /* 0: write, 1: read */
    acc_ctrl.B.AUTO = 0;
    acc_ctrl.B.MSEL = 3; /* 3 = DPCSel */
    acc_ctrl.B.AOFF = daIdx_u8;
    acc_ctrl.B.OB = 1;

    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_DATA.U = regValue_u32;
    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.U = acc_ctrl.U;

    while (MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.B.OB == 1) {}
    return SUCCESS;
}

sint32 Geth_Mac_FailPlcySel_Write(const uint8 gethPort_u8, const uint8 daIdx_u8, const uint32 regValue_u32)
{
    Ifx_GETH_PORT_CORE_MAC_INDIR_ACCESS_CTRL acc_ctrl;
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (daIdx_u8 >= 32u))
    {
      return FAILURE;
    }

    acc_ctrl.B.COM = 0; /* 0: write, 1: read */
    acc_ctrl.B.AUTO = 0;
    acc_ctrl.B.MSEL = 6; /* 6 = FPCSel */
    acc_ctrl.B.AOFF = daIdx_u8;
    acc_ctrl.B.OB = 1;

    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_DATA.U = regValue_u32;
    MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.U = acc_ctrl.U;

    while (MODULE_GETH0.PORT[gethPort_u8].CORE.MAC_INDIR_ACCESS_CTRL.B.OB == 1) {}
    return SUCCESS;
}


sint32 Geth_Mac_TxQueue_Init(const uint8 gethPort_u8, const uint8 queueIndex_u8, const uint8 transmitClass_u8)
{
  if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (queueIndex_u8 >= GETH_MAC_NUMBER_OF_QUEUES) || (transmitClass_u8 >= 8u))
  {
    return FAILURE;
  }

  /*********************************************************************************************************************************************/
  /* ETH_0, DMA Channel 0 */
  /*********************************************************************************************************************************************/
  Ifx_GETH_PORT_MTL_TCQ0_TXQ0_OPERATION_MODE *MTL_TXQ = (Ifx_GETH_PORT_MTL_TCQ0_TXQ0_OPERATION_MODE*)((uint32)&g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.TCQ0.TXQ0_OPERATION_MODE.U + (queueIndex_u8 * 0x80u));

  /* Flush Transmit Queue */
  MTL_TXQ->B.FTQ = 0u;
  /* Transmit Store and Forward */
  MTL_TXQ->B.TSF = 1u;
  /* Transmit Threshold Control,
   * 0 = 64 bytes,
   * 1 = res,
   * 2 = 96 bytes,
   * 3 = 128 bytes,
   * 4 = 256 bytes,
   * 5 = 384 bytes,
   * 6 = 512 bytes
   */
  MTL_TXQ->B.TTC = 0u;
  /* Transmit Queue Size,
   * 0 = 256 bytes,
   * 1 = 512 bytes,
   * 2 = 768 bytes,
   * 3 = 1024 bytes,
   * 4 = 1280 bytes,
   * 5 = 1536 bytes,
   * 6 = 1792 bytes,
   * 7 = 2048 bytes
   */
  MTL_TXQ->B.TQS = (2048u >> 8u) - 1u;
  /* Traffic Class Mapping, 0 = TC0, ..., 7 = TC7 */
  MTL_TXQ->B.Q2TCMAP = transmitClass_u8;
  /* Transmit Queue Enable, 0 = disabled, 1 = AVB, 2 = Enabled */
  MTL_TXQ->B.TXQEN = 2u;

  return SUCCESS;
}

sint32 Geth_Mac_RxQueue_Init(const uint8 gethPort_u8, const uint8 queueIndex_u8)
{
  if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (queueIndex_u8 >= GETH_MAC_NUMBER_OF_QUEUES))
  {
    return FAILURE;
  }

  /*********************************************************************************************************************************************/
  /* ETH_0, DMA Channel 0 */
  /*********************************************************************************************************************************************/
  Ifx_GETH_PORT_MTL_TCQ0_RXQ0_OPERATION_MODE *MTL_RXQ = (Ifx_GETH_PORT_MTL_TCQ0_RXQ0_OPERATION_MODE*)((uint32)&g_gethMac.gethInstance_p->PORT[gethPort_u8].MTL.TCQ0.RXQ0_OPERATION_MODE.U + (queueIndex_u8 * 0x80u));

  /* Receive Queue Size,
   * 0 = 256 bytes,
   * 1 = 512 bytes,
   * 2 = 768 bytes,
   * 3 = 1024 bytes,
   * 4 = 1280 bytes,
   * 5 = 1536 bytes,
   * 6 = 1792 bytes,
   * 7 = 2048 bytes
   */
  MTL_RXQ->B.RQS = (2048u >> 8u) - 1u;
  /* Receive Queue store and forward */
  MTL_RXQ->B.RSF = 1u;
  /* Hardware Flow Control, for Queue Size > 4KB */
  MTL_RXQ->B.EHFC = 0u;
  /* Forward Error Frames (Packets) */
  MTL_RXQ->B.FEF = 0u;
  /* Forward undersized frames (good packets) */
  MTL_RXQ->B.FUF = 0u;
  /* Receive Queue threshold control,
   * 0 = 64 bytes,
   * 1 = res,
   * 2 = 96 bytes,
   * 3 = 128 bytes
   */
  MTL_RXQ->B.RTC = 0u;
  /* enable Rx Queue 0, 0 = disabled, 1 = enabled AV mode, 2 = enabled, generic */
  g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_RXQ_CTRL0.U &= (uint32)~(3u << (queueIndex_u8 * 2));
  g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_RXQ_CTRL0.U |= 2u << (queueIndex_u8 * 2);

  return SUCCESS;
}

sint32 Geth_Mac_enableTransmitReceive(const uint8 gethPort_u8)
{
  if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS))
  {
    return FAILURE;
  }

  /* Transmitter Enable */
  g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TX_CONFIGURATION.B.TE = 1;
  /* Receiver Enable */
  g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_RX_CONFIGURATION.B.RE = 1;

  return SUCCESS;
}

sint32 Geth_Mac_disableTransmitReceive(const uint8 gethPort_u8)
{
  if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS))
  {
    return FAILURE;
  }

  /* Transmitter Enable */
  g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TX_CONFIGURATION.B.TE = 0;
  /* Receiver Enable */
  g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_RX_CONFIGURATION.B.RE = 0;

  return SUCCESS;
}

sint32 Geth_Mac_enableTransmit(const uint8 gethPort_u8)
{
  if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS))
  {
    return FAILURE;
  }

  /* Transmitter Enable */
  g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TX_CONFIGURATION.B.TE = 1;

  return SUCCESS;
}

sint32 Geth_Mac_enableReceive(const uint8 gethPort_u8)
{
  if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS))
  {
    return FAILURE;
  }

  /* Receiver Enable */
  g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_RX_CONFIGURATION.B.RE = 1;

  return SUCCESS;
}

sint32 Geth_Mac_enableServiceRequest(const IfxSrc_Tos typeOfService, const Ifx_Priority priority)
{
    IfxCpu_vmId vmId;
    volatile Ifx_SRC_SRCR *src;

    /* Configure the GETH interrupt */
    vmId = IfxCpu_getVirtualMachine();
    /* Get interrupt address */
    src = IfxGeth_getSrcPointer(IfxGeth_ServiceRequest_INTR);
    /* Initialize the service request */
    IfxSrc_init(src, typeOfService, priority, (IfxSrc_VmId)vmId);
    /* Enable GETH interrupt */
    IfxSrc_enable(src);

    return SUCCESS;
}

sint32 Geth_Mac_getTxTimestamp(const uint8 gethPort_u8, Sys_TimeStamp_t* const timeStamp_p)
{
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (timeStamp_p == NULL))
    {
        return FAILURE;
    }

    if (g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TIMESTAMP_STATUS.B.TXTSC == 0)
    {
        return FAILURE;
    }

    timeStamp_p->packedId = (uint16)g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TX_TIMESTAMP_STATUS_PKTID.U;
    timeStamp_p->nanoSecond = g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TX_TIMESTAMP_STATUS_NANOSECONDS.U;
    timeStamp_p->second = g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TX_TIMESTAMP_STATUS_SECONDS.U;
    timeStamp_p->secOverflow = 0;

    return SUCCESS;
}

sint32 Geth_Mac_getFetchedTxTimestamp(const uint8 gethPort_u8, const uint16 packetId_u16, Sys_TimeStamp_t* const timeStamp_p)
{
    uint8 idx_u8;

    idx_u8 = 0;
    while ((idx_u8 < GETH_NO_OF_TIMESTAMPS) && ((g_gethMac.timeStamp[gethPort_u8][idx_u8].used == 0) || (g_gethMac.timeStamp[gethPort_u8][idx_u8].packedId != packetId_u16)))
    {
        idx_u8++;
    }

    if (idx_u8 < GETH_NO_OF_TIMESTAMPS)
    {
        timeStamp_p->nanoSecond = g_gethMac.timeStamp[gethPort_u8][idx_u8].nanoSecond;
        timeStamp_p->second = g_gethMac.timeStamp[gethPort_u8][idx_u8].second;
        timeStamp_p->secOverflow = g_gethMac.timeStamp[gethPort_u8][idx_u8].secOverflow;
        timeStamp_p->packedId = g_gethMac.timeStamp[gethPort_u8][idx_u8].packedId;
        g_gethMac.timeStamp[gethPort_u8][idx_u8].used = 0;

        return SUCCESS;
    }

    return FAILURE;
}

sint32 Geth_Mac_updateSysTimeAdd(const uint8 gethPort_u8, Sys_TimeStamp_t* const systemTimeUpdate_p)
{
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (systemTimeUpdate_p == NULL))
    {
      return FAILURE;
    }

    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_SYSTEM_TIME_SECONDS_UPDATE.U = systemTimeUpdate_p->second;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.B.TSSS = systemTimeUpdate_p->nanoSecond;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.B.ADDSUB = 0;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TIMESTAMP_CONTROL.B.TSUPDT = 1;

    return SUCCESS;
}

sint32 Geth_Mac_updateSysTimeSub(const uint8 gethPort_u8, Sys_TimeStamp_t* const systemTimeUpdate_p)
{
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS) || (systemTimeUpdate_p == NULL))
    {
      return FAILURE;
    }

    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_SYSTEM_TIME_SECONDS_UPDATE.U = systemTimeUpdate_p->second ^ 0xFFFFFFFF;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.B.TSSS = systemTimeUpdate_p->nanoSecond ^ 0xFFFFFFFF;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.B.ADDSUB = 1;
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TIMESTAMP_CONTROL.B.TSUPDT = 1;

    return SUCCESS;
}

void Geth_timeStampHandler(const uint8 gethPort_u8)
{
    uint8 idx_u8;

    idx_u8 = 0;

    while ((idx_u8 < GETH_NO_OF_TIMESTAMPS) && (g_gethMac.timeStamp[gethPort_u8][idx_u8].used == 1))
    {
        idx_u8++;
    }

    if (idx_u8 < GETH_NO_OF_TIMESTAMPS)
    {
        if (Geth_Mac_getTxTimestamp(gethPort_u8, &g_gethMac.timeStamp[gethPort_u8][idx_u8]) == SUCCESS)
        {
            g_gethMac.timeStamp[gethPort_u8][idx_u8].used = 1;
        }
    }
}

sint32 Geth_Mac_setLinkSpeed(const uint8 gethPort_u8, const uint16 linkSpeed_u16)
{
    ETH_MAC_LINK_SPEED_t linkSpeed;

    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS))
    {
        return FAILURE;
    }

    switch (linkSpeed_u16)
    {
        case 5000:
        {
            linkSpeed = ETH_MAC_LINK_SPEED_5000M;
        } break;
        case 2500:
        {
            linkSpeed = ETH_MAC_LINK_SPEED_2500M;
        } break;
        case 1000:
        {
            linkSpeed = ETH_MAC_LINK_SPEED_1000M;
        } break;
        case 100:
        {
            linkSpeed = ETH_MAC_LINK_SPEED_100M;
        } break;
        case 10:
        default:
        {
            linkSpeed = ETH_MAC_LINK_SPEED_10M;
        } break;
    }
    g_gethMac.gethInstance_p->PORT[gethPort_u8].CORE.MAC_TX_CONFIGURATION.B.SS = linkSpeed;

    return SUCCESS;
}

sint32 Geth_Mac_TAS_enableSoftwareList(const uint8 gethPort_u8)
{
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS))
    {
      return FAILURE;
    }

    MODULE_GETH0.PORT[gethPort_u8].MTL.EST_CONTROL.B.SSWL = 1;

    return SUCCESS;
}

sint32 Geth_Mac_TAS_disableSoftwareList(const uint8 gethPort_u8)
{
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS))
    {
      return FAILURE;
    }

    MODULE_GETH0.PORT[gethPort_u8].MTL.EST_CONTROL.B.SSWL = 0;

    return SUCCESS;
}

boolean Geth_Mac_TAS_isSoftwareListActive(const uint8 gethPort_u8)
{
    if ((g_gethMac.initDone_u8 == 0) || (gethPort_u8 >= GETH_MAC_NUMBER_OF_MACS))
    {
      return FALSE;
    }

    return MODULE_GETH0.PORT[gethPort_u8].MTL.EST_STATUS.B.SWLC == 1 ? TRUE : FALSE;
}
