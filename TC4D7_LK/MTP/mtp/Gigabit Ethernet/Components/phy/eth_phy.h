/**
 * \file eth_phy.h
 * \brief Functions to interface to the on-board ethernet phys
 *
 * \version V0.1.0
 * \copyright Copyright (c) 2019-2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or 
 * the company in which ordinary course of business you are acting and (ii) 
 * Infineon Technologies AG or its licensees. If and as long as no such 
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or 
 * organization obtaining a copy of the software and accompanying 
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the 
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*******************************************************************************
**                             Author(s) Identity                             **
********************************************************************************
** Initials     Name                                                          **
** ---------------------------------------------------------------------------**
** RS           Ronny Schulze                                                 **
** DM           Daniel Mysliwitz                                              **
*******************************************************************************/

/*******************************************************************************
**                          Revision Control History                          **
********************************************************************************
** V0.1.0: 2021-03-16, DM:   Initial version                                  **
*******************************************************************************/

#ifndef ETH_PHY_H
#define ETH_PHY_H

/*******************************************************************************
 * INCLUDES
 *******************************************************************************/
#include "Cpu/Std/Ifx_Types.h"
#include "IfxPort.h"
#include "IfxGeth_PinMap.h"
#include "IfxLeth_PinMap.h"

/*******************************************************************************
 * MACROS
 *******************************************************************************/
#define ETH_PHY_CONFIG_INTERFACE_Msk 0x7
#define ETH_PHY_CONFIG_INTERFACE_Pos 12
#define ETH_PHY_CONFIG_LINK_MODE_Msk 0x3F
#define ETH_PHY_CONFIG_LINK_MODE_Pos 0
#define ETH_PHY_CONFIG_ADVERTISING_Msk (1 << 7)
#define ETH_PHY_CONFIG_ADVERTISE_10_100_Msk 0x0f
#define ETH_PHY_CONFIG_ADVERTISE_10_100_Pos 0
#define ETH_PHY_CONFIG_ADVERTISE_1000_Msk 0x30
#define ETH_PHY_CONFIG_ADVERTISE_1000_Pos 4
#define ETH_PHY_MDIO_TIMEOUT (0xffffffffUL)
#define ETH_PHY_MDIO_C45 (0x80000000UL)


/*******************************************************************************
 * ENUMS
 *******************************************************************************/

/**
 * ETH PHY interface mode
 */
typedef enum ETH_PHY_STATUS
{
  ETH_PHY_STATUS_OK = 0,             /**< OK. All is fine! */
  ETH_PHY_STATUS_BUSY = -1,          /**< Busy */
  ETH_PHY_STATUS_ERROR = -2,         /**< Error */
  ETH_PHY_STATUS_ERROR_ID = -3,      /**< Error in device identifier */
  ETH_PHY_STATUS_ERROR_TIMEOUT = -4, /**< Time-out error */  
  ETH_PHY_STATUS_ERROR_IF = -5,       /**< Interface mode not supported */
  ETH_PHY_STATUS_ERROR_PHYANEG = -6,
  ETH_PHY_STATUS_ERROR_SPEED = -7,
  ETH_PHY_STATUS_ERROR_PHYREMRX = -8
} ETH_PHY_STATUS_t;

/**
 * ETH_PHY speed
 */ 
typedef enum ETH_PHY_LINK_SPEED
{
  ETH_PHY_LINK_SPEED_10M   = 10,
  ETH_PHY_LINK_SPEED_100M  = 100,
  ETH_PHY_LINK_SPEED_1000M = 1000,
  ETH_PHY_LINK_SPEED_2500M = 2500,
  ETH_PHY_LINK_SPEED_5000M = 5000,
  ETH_PHY_LINK_SPEED_UNKOWN = 0,
} ETH_PHY_LINK_SPEED_t;

/**
 * ETH_PHY link mode
 */ 
typedef enum ETH_PHY_LINK_DUPLEX
{
  ETH_PHY_LINK_DUPLEX_HALF,
  ETH_PHY_LINK_DUPLEX_FULL,
  ETH_PHY_LINK_DUPLEX_UNKOWN,
} ETH_PHY_LINK_DUPLEX_t;

/**
 * ETH_PHY link status
 */ 
typedef enum ETH_PHY_LINK_STATUS
{
  ETH_PHY_LINK_STATUS_DOWN,
  ETH_PHY_LINK_STATUS_UP,
  ETH_PHY_LINK_STATUS_UNKNOWN,
} ETH_PHY_LINK_STATUS_t;

/**
 * ETH_PHY config
 */ 
typedef enum ETH_PHY_CONFIG
{
  ETH_PHY_CONFIG_LINK_MODE_10BASET_HALF  = 1 << 0, // (ETH_PHY_LINK_SPEED_10M << ETH_PHY_CONFIG_SPEED_Pos) | (ETH_PHY_LINK_DUPLEX_HALF << ETH_PHY_CONFIG_DUPLEX_Pos),
  ETH_PHY_CONFIG_LINK_MODE_10BASET_FULL  = 1 << 1, // (ETH_PHY_LINK_SPEED_10M << ETH_PHY_CONFIG_SPEED_Pos) | (ETH_PHY_LINK_DUPLEX_FULL << ETH_PHY_CONFIG_DUPLEX_Pos),
  ETH_PHY_CONFIG_LINK_MODE_100BASET_HALF = 1 << 2, // (ETH_PHY_LINK_SPEED_100M << ETH_PHY_CONFIG_SPEED_Pos) | (ETH_PHY_LINK_DUPLEX_HALF << ETH_PHY_CONFIG_DUPLEX_Pos),
  ETH_PHY_CONFIG_LINK_MODE_100BASET_FULL = 1 << 3, //(ETH_PHY_LINK_SPEED_100M << ETH_PHY_CONFIG_SPEED_Pos) | (ETH_PHY_LINK_DUPLEX_FULL << ETH_PHY_CONFIG_DUPLEX_Pos),
  ETH_PHY_CONFIG_LINK_MODE_1000BASET_HALF  = 1 << 4, //(ETH_PHY_LINK_SPEED_1000M << ETH_PHY_CONFIG_SPEED_Pos) | (ETH_PHY_LINK_DUPLEX_FULL << ETH_PHY_CONFIG_DUPLEX_Pos),
  ETH_PHY_CONFIG_LINK_MODE_1000BASET_FULL  = 1 << 5, //(ETH_PHY_LINK_SPEED_1000M << ETH_PHY_CONFIG_SPEED_Pos) | (ETH_PHY_LINK_DUPLEX_FULL << ETH_PHY_CONFIG_DUPLEX_Pos),

  ETH_PHY_CONFIG_ADVERTISING_SUPPORTED_10BASET_HALF = ETH_PHY_CONFIG_ADVERTISING_Msk | ETH_PHY_CONFIG_LINK_MODE_10BASET_HALF,
  ETH_PHY_CONFIG_ADVERTISING_SUPPORTED_10BASET_FULL = ETH_PHY_CONFIG_ADVERTISING_Msk | ETH_PHY_CONFIG_LINK_MODE_10BASET_FULL,
  ETH_PHY_CONFIG_ADVERTISING_SUPPORTED_100BASET_HALF = ETH_PHY_CONFIG_ADVERTISING_Msk | ETH_PHY_CONFIG_LINK_MODE_100BASET_HALF,
  ETH_PHY_CONFIG_ADVERTISING_SUPPORTED_100BASET_FULL = ETH_PHY_CONFIG_ADVERTISING_Msk | ETH_PHY_CONFIG_LINK_MODE_100BASET_FULL,
  ETH_PHY_CONFIG_ADVERTISING_SUPPORTED_1000BASET_HALF = ETH_PHY_CONFIG_ADVERTISING_Msk | ETH_PHY_CONFIG_LINK_MODE_1000BASET_HALF,
  ETH_PHY_CONFIG_ADVERTISING_SUPPORTED_1000BASET_FULL = ETH_PHY_CONFIG_ADVERTISING_Msk | ETH_PHY_CONFIG_LINK_MODE_1000BASET_FULL,

  ETH_PHY_CONFIG_AUTONEG  = 1 << 8,
  ETH_PHY_CONFIG_LOOPBACK = 1 << 9,
  ETH_PHY_CONFIG_MASTER   = 1 << 10,
  ETH_PHY_CONFIG_AUTO_OP  = 1 << 11,

  ETH_PHY_CONFIG_INTERFACE_MII = 0 << 12,
  ETH_PHY_CONFIG_INTERFACE_RMII = 1 << 12,
  ETH_PHY_CONFIG_INTERFACE_GMII = 2 << 12,
  ETH_PHY_CONFIG_INTERFACE_RGMII = 3 << 12,
  ETH_PHY_CONFIG_INTERFACE_RGMII_ID = 4 << 12,
  ETH_PHY_CONFIG_INTERFACE_RGMII_RXID = 5 << 12,
  ETH_PHY_CONFIG_INTERFACE_RGMII_TXID = 6 << 12,

  ETH_PHY_CONFIG_ENABLE_CLKOUT  = 1 << 16,
} ETH_PHY_CONFIG_t;

/**
 * ETH_PHY interface
 */
typedef enum ETH_PHY_INTERFACE
{
  ETH_PHY_INTERFACE_MII = 0,
  ETH_PHY_INTERFACE_RMII,
  ETH_PHY_INTERFACE_GMII,
  ETH_PHY_INTERFACE_RGMII,
  ETH_PHY_INTERFACE_SGMII,
  ETH_PHY_INTERFACE_XGMII,
  ETH_PHY_INTERFACE_TC14
} ETH_PHY_INTERFACE_t;

typedef enum
{
    ETH_TYPE_LETH = 0,
    ETH_TYPE_GETH
} ETH_TYPE_t;


typedef struct GETH_PHY_IO
{
    ETH_PHY_INTERFACE_t ethPhyInterface;
    struct
    {
        IfxGeth_Crsdv_In    *const crsdv;
        IfxGeth_Rxd_In     *const rxd0;
        IfxGeth_Rxd_In     *const rxd1;
        IfxGeth_Txen_Out   *const txen;
        IfxGeth_Txd_Out    *const txd0;
        IfxGeth_Txd_Out    *const txd1;
        IfxGeth_Refclk_In  *const refclk;
    } RMII;
    struct
    {
        IfxGeth_Refclk_In *const rxc;
        IfxGeth_Rxd_In *const rxd0;
        IfxGeth_Rxd_In *const rxd1;
        IfxGeth_Rxd_In *const rxd2;
        IfxGeth_Rxd_In *const rxd3;
        IfxGeth_Rxctl_In *const rxctl;
        IfxGeth_Txclk_Out *const txc;
        IfxGeth_Txd_Out *const txd0;
        IfxGeth_Txd_Out *const txd1;
        IfxGeth_Txd_Out *const txd2;
        IfxGeth_Txd_Out *const txd3;
        IfxGeth_Txctl_Out *const txctl;
        IfxGeth_Grefclk_In *const grefclk;
    } RGMII;
    struct
    {
        IfxGeth_Mdc_Out *const mdc;
        IfxGeth_Mdio_InOut *const mdio;
        IfxPort_Pin *const reset;
        IfxPort_Pin *const intb;
    } MDIO;
} GETH_PHY_IO_t;

typedef struct LETH_PHY_IO
{
    ETH_PHY_INTERFACE_t ethPhyInterface;
    struct
    {
        IfxLeth_P_In  *const rxd;
        IfxLeth_P_In  *const ed;
        IfxLeth_P_Out *const txd;
        uint8 nodeId;
        uint8 maxNoOfNodes;
        float toBitTimes;
    } TC14;
    struct
    {
        IfxLeth_P_In  *const rxc;
        IfxLeth_P_In  *const rxd0;
        IfxLeth_P_In  *const rxd1;
        IfxLeth_P_In  *const rxd2;
        IfxLeth_P_In  *const rxd3;
        IfxLeth_P_In  *const rxdv;
        IfxLeth_P_In  *const rxer;
        IfxLeth_P_In  *const crs;
        IfxLeth_P_In  *const col;
        IfxLeth_P_Out  *const txc;
        IfxLeth_P_Out *const txd0;
        IfxLeth_P_Out *const txd1;
        IfxLeth_P_Out *const txd2;
        IfxLeth_P_Out *const txd3;
        IfxLeth_P_Out *const txen;
        IfxLeth_P_Out *const txer;
    } MII;
    struct
    {
        IfxLeth_P_In  *const rxdv;
        IfxLeth_P_In  *const rxd0;
        IfxLeth_P_In  *const rxd1;
        IfxLeth_P_Out *const txen;
        IfxLeth_P_Out *const txd0;
        IfxLeth_P_Out *const txd1;
        IfxLeth_P_In  *const rxclk;
    } RMII;
    struct
    {
        IfxLeth_P_Out *const mdc;
        IfxLeth_P_InOut *const mdio;
        IfxPort_Pin *const reset;
        IfxPort_Pin *const intb;
    } MDIO;
} LETH_PHY_IO_t;

typedef struct ETH_PHY_t ETH_PHY_t;

typedef struct
{
    sint32(*mdio_write)(uint8 phy_addr, uint16 reg_addr, uint16 reg_val);
    sint32(*mdio_read)(uint8 phy_addr, uint16 reg_addr, uint16 *const reg_val);
    sint32(*mdio_write_c45)(uint8 phy_addr, uint8 dev_addr, uint16 reg_addr, uint16 reg_val);
    sint32(*mdio_read_c45)(uint8 phy_addr, uint8 dev_addr, uint16 reg_addr, uint16 *const reg_val);
    sint32 (*phy_init)(ETH_PHY_t *const phyInstance_p);
    sint32 (*phy_ethLinkUp)(ETH_PHY_t *const phyInstance_p, uint16 * const speed_u16);
    sint32 (*phy_miiLinkUp)(ETH_PHY_t *const phyInstance_p);
} ETH_PHY_FUNC_t;

struct ETH_PHY_t
{
  uint8 peripheryIdx_u8;
  uint8 phyAddr_u8;
  uint8 hsphyPort_u8; /* 0 = HSPHY_Port0, 1 = HSPHY_Port1, 2 = HSPHY_Port2 */
  uint8 mdioPort_u8;  /* 0 = HSPHY_Port0, 1 = HSPHY_Port1, 2 = HSPHY_Port2 */
  uint8 mdioType;  /* ETH_TYPE_LETH, ETH_TYPE_GETH */
  uint8 macPort_u8;  /* 0 = HSPHY_Port0, 1 = HSPHY_Port1, 2 = HSPHY_Port2 */
  uint8 phyClause45_u8; /* 0 = Clause45 not supported, 1 = Clause45 supported */
  ETH_TYPE_t ethType; /* ETH_TYPE_LETH, ETH_TYPE_GETH */
  GETH_PHY_IO_t gethPhyIo;
  LETH_PHY_IO_t lethPhyIo;
  ETH_PHY_FUNC_t ethPhyFunc;
} ;

/*******************************************************************************
 * API PROTOTYPES
 *******************************************************************************/
#if 1
#ifdef __cplusplus
extern "C" {
#endif

sint32 ETH_PHY_Reset(ETH_PHY_t *const handle);

sint32 ETH_PHY_IsResetDone(ETH_PHY_t *const handle);

sint32 ETH_PHY_Suspend(ETH_PHY_t *const handle);

sint32 ETH_PHY_Resume(ETH_PHY_t *const handle);

sint32 ETH_PHY_GetPhyId(ETH_PHY_t *const handle, uint32 phy_id, uint32 phy_id_msk);

sint32 ETH_PHY_IsAutonegotiationEnabled(ETH_PHY_t *const handle);

sint32 ETH_PHY_IsAutonegotiationDone(ETH_PHY_t *const handle);

sint32 ETH_PHY_RestartAutonegotiation(ETH_PHY_t *const handle);

sint32 ETH_PHY_IsRemoteReceiverOk(ETH_PHY_t *const handle);

sint32 ETH_PHY_WriteMmdIndirect(ETH_PHY_t *const handle, uint8 dev_addr, uint16 mmd_addr, uint16 data);

sint32 ETH_PHY_ReadMmdIndirect(ETH_PHY_t *const handle, uint8 dev_addr, uint16 mmd_addr, uint16 *const data);

sint32 ETH_PHY_ClearEeeAdv(ETH_PHY_t *const handle);

/**
 * @brief Release reset for external Phy
 * @param phyInstance_p pointer to external Phy instance
 * @return SUCCESS or FAILURE
 */
sint32 Eth_deassertPhyReset(ETH_PHY_t *const phyInstance_p);

/**
 * @brief Set external Phy into reset state
 * @param phyInstance_p pointer to external Phy instance
 * @return SUCCESS or FAILURE
 */
sint32 Eth_assertPhyReset(ETH_PHY_t *const phyInstance_p);

sint32 Eth_defaultPhyInit(ETH_PHY_t *const phyInstance_p);

sint32 Eth_defaultPhyLinkUp(ETH_PHY_t *const phyInstance_p, uint16 * const speed_u16);

#ifdef __cplusplus
}
#endif
#endif

#endif

