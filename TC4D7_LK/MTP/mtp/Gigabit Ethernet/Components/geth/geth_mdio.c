/**
 * \file geth_mdio.c
 * \brief Functions to interface to the Geth MDIO
 *
 * \version see header file
 * \copyright Copyright (c) 2019-2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#include "geth_mdio.h"
#include "geth_mac.h"

/* MDIO defines */
#define GETH_MAC_MDIO_MAX_RETRIES   0xffffffff
#define GETH_MAC_MDIO_BUSY          0x004000000 // bit 22 Porti_MDIO_Single_Command_Control_Data
#define GETH_MAC_MDIO_WRITE         (1 << 16) //search for offset IFX declaration later
#define GETH_MAC_MDIO_READ          (3 << 16)

sint32 geth0_mdio_write_cl22(uint8 phy_addr, uint16 reg_addr, uint16 reg_val)
{
  return Geth_Mdio_Write(&MODULE_GETH0, GETH_MAC0 , phy_addr, 0, reg_addr, reg_val, 0xffffffff);
}

sint32 geth0_mdio_read_cl22(uint8 phy_addr, uint16 reg_addr, uint16 *const reg_val)
{
  return Geth_Mdio_Read(&MODULE_GETH0, GETH_MAC0, phy_addr, 0, reg_addr, reg_val, 0xffffffff);
}

sint32 geth0_mdio_write_cl45(uint8 phy_addr, uint8 dev_addr, uint16 reg_addr, uint16 reg_val)
{
//  return Geth_Mdio_Write(&MODULE_GETH0, GETH_MAC0 , phy_addr, dev_addr, reg_addr, reg_val, 0xffffffff);
  return Geth_Mdio_Write(&MODULE_GETH0, GETH_MAC0 , phy_addr, dev_addr, reg_addr, reg_val, 0xfff);
}

sint32 geth0_mdio_read_cl45(uint8 phy_addr, uint8 dev_addr, uint16 reg_addr, uint16 *const reg_val)
{
  //return Geth_Mdio_Read(&MODULE_GETH0, GETH_MAC0, phy_addr, dev_addr, reg_addr, reg_val, 0xffffffff);
  return Geth_Mdio_Read(&MODULE_GETH0, GETH_MAC0, phy_addr, dev_addr, reg_addr, reg_val, 0xfff);
}

sint32 geth1_mdio_write_cl22(uint8 phy_addr, uint16 reg_addr, uint16 reg_val)
{
  return Geth_Mdio_Write(&MODULE_GETH0, GETH_MAC1 , phy_addr, 0, reg_addr, reg_val, 0xffffffff);
}

sint32 geth1_mdio_read_cl22(uint8 phy_addr, uint16 reg_addr, uint16 *const reg_val)
{
  return Geth_Mdio_Read(&MODULE_GETH0, GETH_MAC1, phy_addr, 0, reg_addr, reg_val, 0xffffffff);
}

sint32 geth1_mdio_write_cl45(uint8 phy_addr, uint8 dev_addr, uint16 reg_addr, uint16 reg_val)
{
  return Geth_Mdio_Write(&MODULE_GETH0, GETH_MAC1 , phy_addr, dev_addr, reg_addr, reg_val, 0xffffffff);
}

sint32 geth1_mdio_read_cl45(uint8 phy_addr, uint8 dev_addr, uint16 reg_addr, uint16 *const reg_val)
{
  return Geth_Mdio_Read(&MODULE_GETH0, GETH_MAC1, phy_addr, dev_addr, reg_addr, reg_val, 0xffffffff);
}

/*
 *      MDIO read function
 *      if dev_addr = 0 we send in clause 22
 *      else we send in clause 45
 */
sint32 Geth_Mdio_Read(Ifx_GETH *const gethInstance_p, const uint8 macIndex_u8, const uint8 phyAddr_u8, const uint8 devAddr_u8, const uint16 regNum_u16, uint16 *const regVal_p, uint32 timeOut_u32)
{
    Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS mdio_addr;
    Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA mdio_data;

    /* check the port index */
    if (macIndex_u8 >= GETH_MAC_NUMBER_OF_MACS)
    {
        return FAILURE;
    }

    /* Wait until any existing MII operation is complete */
    while ((gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY == 1u) && (timeOut_u32 > 0))
    {
        timeOut_u32--;
    }

    if (timeOut_u32 == 0u)
    {
        return FAILURE;
    }

    mdio_data.U = gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U;
    mdio_data.B.CMD = 3; /* Read */
    mdio_data.B.CR = 5; /* MDC = 1.98..2.47MHz */
    gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U = mdio_data.U;

    mdio_addr.U = 0u;
    mdio_addr.B.PA = phyAddr_u8;
    mdio_addr.B.DA = devAddr_u8;
    mdio_addr.B.RA = regNum_u16;
    gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_ADDRESS.U = mdio_addr.U;

    gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY = 1;

    while ((gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY == 1u) && (timeOut_u32 > 0))
    {
        timeOut_u32--;
    }

    if (timeOut_u32 == 0u)
    {
        return FAILURE;
    }

    *regVal_p = (uint16)gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SDATA;

    return SUCCESS;
}

/*
 *      MDIO write function
 */
sint32 Geth_Mdio_Write(Ifx_GETH *const gethInstance_p, const uint8 macIndex_u8, const uint8 phyAddr_u8, const uint8 devAddr_u8, const uint16 regNum_u16, uint16 regVal_u16, uint32 timeOut_u32)
{
    Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS mdio_addr;
    Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA mdio_data;

    /* check the port index */
    if (macIndex_u8 >= GETH_MAC_NUMBER_OF_MACS)
    {
        return FAILURE;
    }

    /* Wait until any existing MII operation is complete */
    while ((gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY == 1u) && (timeOut_u32 > 0))
    {
        timeOut_u32--;
    }

    if (timeOut_u32 == 0u)
    {
        return FAILURE;
    }

    mdio_data.U = gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U;
    mdio_data.B.CMD = 1; /* Write */
    mdio_data.B.CR = 5; /* MDC = 1.98..2.47MHz */
    mdio_data.B.SDATA = regVal_u16;
    gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U = mdio_data.U;

    mdio_addr.U = 0u;
    mdio_addr.B.PA = phyAddr_u8;
    mdio_addr.B.DA = devAddr_u8;
    mdio_addr.B.RA = regNum_u16;
    gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_ADDRESS.U = mdio_addr.U;

    gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY = 1;

    while ((gethInstance_p->PORT[macIndex_u8].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY == 1u) && (timeOut_u32 > 0))
    {
        timeOut_u32--;
    }

    if (timeOut_u32 == 0u)
    {
        return FAILURE;
    }

    return SUCCESS;
}
