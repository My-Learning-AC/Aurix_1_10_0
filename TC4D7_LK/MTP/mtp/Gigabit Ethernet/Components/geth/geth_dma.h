/**
 * \file geth_dma.h
 * \brief Functions to interface to the Geth DMA
 *
 * \version V0.1.3
 * \copyright Copyright (c) 2019-2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*******************************************************************************
**                             Author(s) Identity                             **
********************************************************************************
** Initials     Name                                                          **
** ---------------------------------------------------------------------------**
** RS           Ronny Schulze                                                 **
** DM           Daniel Mysliwitz                                              **
*******************************************************************************/

/*******************************************************************************
**                          Revision Control History                          **
********************************************************************************
** V0.1.0: 2021-11-16, DM:   Initial version                                  **
********************************************************************************
** V0.1.1: 2021-11-22, DM:   in function Geth_Dma_transmitBuffer and          **
**                           Geth_Dma_receiveBuffer, the buffer pointer has   **
**                           been changed to type void                        **
********************************************************************************
** V0.1.2: 2022-02-02, DM:   fixing Tx/RxDescriptor type handling,            **
**                           descriptor ring length calculation fixed         **
********************************************************************************
** V0.1.3: 2022-02-18, DM:   fixing Tx/Rx interrupt handling                  **
********************************************************************************
** V0.1.4: 2022-06-07, DM:   adding timestamp enable control to function      **
**                           Geth_Dma_setTxBufferSize()                       **
*******************************************************************************/

#ifndef COMPONENTS_DMA_GETH_DMA_H_
#define COMPONENTS_DMA_GETH_DMA_H_

#include "types.h"
#include "IfxSrc_regdef.h"
#include "_Impl/IfxSrc_cfg.h"
#include "IfxGeth_regdef.h"
#include "geth_dma_dscr.h"
#ifdef IFX_SOLUTION_DESIGNER_GETH_ENABLE
    #include "tc4d_geth_dma_cfg.h"
#endif /* IFX_SOLUTION_DESIGNER_GETH_ENABLE */
#include "geth_mac.h"
/**********************************************************************************************************************
 * MACROS
 *********************************************************************************************************************/
/* Number of DMA channels */
#define GETH_DMA_NUMBER_OF_CHANNELS (8u)

#define GETH_DMA_CHANNEL0 (0u)
#define GETH_DMA_CHANNEL1 (1u)
#define GETH_DMA_CHANNEL2 (2u)
#define GETH_DMA_CHANNEL3 (3u)
#define GETH_DMA_CHANNEL4 (4u)
#define GETH_DMA_CHANNEL5 (5u)
#define GETH_DMA_CHANNEL6 (6u)
#define GETH_DMA_CHANNEL7 (7u)

/**********************************************************************************************************************
 * ENUMS
 *********************************************************************************************************************/
/**
 * ETH MAC event
 */
typedef enum ETH_DMA_EVENT
{
  ETH_DMA_EVENT_CONTEXT_DESC_ERROR          = 0x2000,  /**< Context Descriptor error */
  ETH_DMA_EVENT_BUS_ERROR                   = 0x1000,  /**< Bus error */
  ETH_DMA_EVENT_EARLY_RECEIVE               = 0x0800,  /**< Early receive */
  ETH_DMA_EVENT_EARLY_TRANSMIT              = 0x0400,  /**< Early transmit */
  ETH_DMA_EVENT_RECEIVE_WATCHDOG_TIMEOUT    = 0x0200,  /**< Receive watchdog time-out */
  ETH_DMA_EVENT_RECEIVE_PROCESS_STOPPED     = 0x0100,  /**< Receive process stopped */
  ETH_DMA_EVENT_RECEIVE_BUFFER_UNAVAILABLE  = 0x0080,  /**< Receive buffer unavailable */
  ETH_DMA_EVENT_RECEIVE                     = 0x0040,  /**< Receive event */
  ETH_DMA_EVENT_TRANSMIT_BUFFER_UNAVAILABLE = 0x0004,  /**< Transmit buffer unavailable */
  ETH_DMA_EVENT_TRANSMIT_PROCESS_STOPPED    = 0x0002,  /**< Transmit process stopped */
  ETH_DMA_EVENT_TRANSMIT                    = 0x0001   /**< Transmit event */
} ETH_DMA_EVENT_t;

/**********************************************************************************************************************
 * DATA STRUCTURES
 *********************************************************************************************************************/
typedef struct
{
    union
    {
        GethTxDescriptor        *txDscr_p;      /**< DMA descriptors */
        GethTxCombiDescriptor   *combiTxDscr_p; /**< DMA combi descriptors */
        GethTxEnhDescriptor     *enhTxDscr_p;   /**< DMA enhanced descriptor */
        GethRxDescriptor        *rxDscr_p;      /**< DMA descriptors */
        GethRxCombiDescriptor   *combiRxDscr_p; /**< DMA combi descriptors */
    } dscr;
    GethRxDescriptor       rxDscrStack; /**< DMA combi descriptors */
    uint8 dscrType;
    uint16 dscrCnt_u16;                       /**< How many descriptors? */
    uint8 *bufs;                              /**< buffers associated to descriptors */
    uint32 maxBuffSize_u32;                   /**< max. size of buffers */
    uint16 dscrIdx_u16;                       /**< current descriptor index */
    uint16 nullDscrIdx_u16;                   /**< null descriptor index */
} GethDmaChannel_t;

typedef struct
{
    Ifx_GETH *gethInstance_p;
    uint8 initDone_u8;
    uint8 channelCnt_u8;
    GethDmaChannel_t rxChannel[GETH_DMA_NUMBER_OF_CHANNELS];
    GethDmaChannel_t txChannel[GETH_DMA_NUMBER_OF_CHANNELS];
} GethDma_t;

/**
 * @brief Initializes the DMA software structure based on ConfigWizard settings
 * @param macInstance_p pointer to the ethernet register block
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_initStruct(Ifx_GETH *const gethInstance_p);

/**
 * @brief Initializes the DMA module based on ConfigWizard settings
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_Init(uint32 timeOut_u32);

/**
 * @brief Initializes the DMA transmit channel
 * @param dmaChannel_u8 DMA channel index
 * @param txReadDscr_p pointer to transmit descriptor list
 * @param numberOfTxDescriptors_u8 number of descriptor slots in transmit descriptor list
 * @param rxReadDscr_p pointer to transmit descriptor list
 * @param numberOfRxDescriptors_u8 number of descriptor slots in receive descriptor list
 * @param rxBufferSize_u32 receive buffer size in bytes
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_Channel_Init(const uint8 dmaChannel_u8, GethTxReadDescriptor *const txReadDscr_p, const uint8 numberOfTxDescriptors_u8, GethRxReadDescriptor *const rxReadDscr_p, const uint8 numberOfRxDescriptors_u8, const uint32 rxBufferSize_u32);

/**
 * @brief This function enters a new descriptor entry into the Tx descriptor ring for the selected DMA, and triggers the DMA to transmit.
 * @param dmaChannel_u8 DMA channel index
 * @param buffer_p pointer to the buffer to be sent
 * @param bufferSize_u32 buffer size in bytes
 * @return SUCCESS = transmit request entered into descr. ring, else FAILURE
 */
sint32 Geth_Dma_transmitBuffer(const uint8 dmaChannel_u8, void *const buffer_p, const size_t bufferSize_u32);

/**
 * @brief This function sends a Layer 2 frame
 * @param dmaChannel_u8 DMA channel index
 * @param buffer_p pointer to the buffer to be sent
 * @param bufferSize_u32 buffer size in bytes
 * @return SUCCESS = transmit request entered into descr. ring, else FAILURE
 */
sint32 Geth_L2_transmitFrame(const uint8 dmaChannel_u8, uint8 *const destAddr_p, uint8 *const srcAddr_p, const uint16 etherType_u16, uint8 *const payload_p, const size_t payloadSize);

/**
 * @brief This function enters a new descriptor entry into the Rx descriptor ring for the selected DMA.
 * @param dmaChannel_u8 DMA channel index
 * @param buffer_p pointer to the buffer to be sent
 * @return index into descriptor ring, -1 error
 */
sint16 Geth_Dma_receiveBuffer(const uint8 dmaChannel_u8, void *const buffer_p);

/**
 * @brief Enable the DMA for transmitting and receiving
 * @param macInstance_p pointer to the ethernet register block
 * @param dmaChannel_u8 DMA channel index
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_Start(const uint8 dmaChannel_u8);
sint32 Geth_Dma_startTransmit(const uint8 dmaChannel_u8);
sint32 Geth_Dma_startReceive(const uint8 dmaChannel_u8);

/**
 * @brief Disable the DMA for transmitting and receiving
 * @param macInstance_p pointer to the ethernet register block
 * @param dmaChannel_u8 DMA channel index
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_Stop(const uint8 dmaChannel_u8);

/**
 * @brief Register an interrupt request for the DMA Tx channel
 * @param dmaChannel_u8 DMA channel index
 * @param typeOfService selecting interrupt service provider
 * @param priority interrupt priority value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_enableTxServiceRequest(const uint8 dmaChannel_u8, const IfxSrc_Tos typeOfService, const Ifx_Priority priority);

/**
 * @brief Register an interrupt request for the DMA Rx channel
 * @param dmaChannel_u8 DMA channel index
 * @param typeOfService selecting interrupt service provider
 * @param priority interrupt priority value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_enableRxServiceRequest(const uint8 dmaChannel_u8, const IfxSrc_Tos typeOfService, const Ifx_Priority priority);

/**
 * @brief Rearm the receive descriptor to be used by the DMA
 * @param dmaChannel_u8 DMA channel index
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_returnRxDescriptor(const uint8 dmaChannel_u8);

/**
 * @brief Rearm the transmit descriptor to be used by the DMA
 * @param dmaChannel_u8 DMA channel index
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_returnTxDescriptor(const uint8 dmaChannel_u8);

/**
 * @brief Read the frame size for the received frame
 * @param dmaChannel_u8 DMA channel index
 * @param frameSize_p frame size return value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_getRxFrameSize(const uint8 dmaChannel_u8, uint32 *const frameSize_p);

/**
 * @brief Read the buffer size for the receive frames
 * @param dmaChannel_u8 DMA channel index
 * @param bufferSize_p buffer size return value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_getRxBufferSize(const uint8 dmaChannel_u8, uint32 *const bufferSize_p);

/**
 * @brief Read the buffer size for the transmit frames
 * @param dmaChannel_u8 DMA channel index
 * @param bufferSize_p buffer size return value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_getTxBufferSize(const uint8 dmaChannel_u8, uint32 *const bufferSize_p);

/**
 * @brief Set the buffer size for the transmit frames
 * @param dmaChannel_u8 DMA channel index
 * @param bufferSize_u32 buffer size value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_setTxBufferSize(const uint8 dmaChannel_u8, uint32 bufferSize_u32);

/**
 * @brief Set the maximum buffer size for the receive frames
 * @param dmaChannel_u8 DMA channel index
 * @param maxBufferSize_u32 maximum buffer size value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_setRxMaxBufferSize(const uint8 dmaChannel_u8, const uint32 maxBufferSize_u32);

/**
 * @brief Set the maximum buffer size for the transmit frames
 * @param dmaChannel_u8 DMA channel index
 * @param maxBufferSize_u32 maximum buffer size value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_setTxMaxBufferSize(const uint8 dmaChannel_u8, const uint32 maxBufferSize_u32);

/**
 * @brief Check whether current receive descriptor is owned by DMA
 * @param dmaChannel_u8 DMA channel index
 * @return TRUE = descriptor owned by DMA, FALSE = descriptor owned by application
 */
boolean Geth_Dma_isRxDscriptorOwnedByDma(const uint8 dmaChannel_u8);
boolean Geth_Dma_isAnyRxDscriptorOwnedByDma(const uint8 dmaChannel_u8);
boolean Geth_Dma_isRxDscriptorXOwnedByDma(const uint8 dmaChannel_u8, const uint16 dscrIdx_u16);
sint32 Geth_Dma_setNullDescriptor(const uint8 dmaChannel_u8, const uint16 dscrIdx_u16);
sint32 Geth_Dma_activateNullDescriptor(const uint8 dmaChannel_u8, const uint16 dscrIdx_u16);
sint32 Geth_Dma_restoreNullDescriptor(const uint8 dmaChannel_u8);

/**
 * @brief Check whether current transmit descriptor is owned by DMA
 * @param dmaChannel_u8 DMA channel index
 * @return TRUE = descriptor owned by DMA, FALSE = descriptor owned by application
 */
boolean Geth_Dma_isTxDscriptorOwnedByDma(const uint8 dmaChannel_u8);

/**
 * @brief Retrigger transmit DMA to process descriptor list
 * @param dmaChannel_u8 DMA channel index
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_resumeTxDma(const uint8 dmaChannel_u8);

/**
 * @brief Retrigger receive DMA to process descriptor list
 * @param dmaChannel_u8 DMA channel index
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_resumeRxDma(const uint8 dmaChannel_u8);

/**
 * @brief Read the pointer to the transmit buffer
 * @param dmaChannel_u8 DMA channel index
 * @param buffer_pp buffer pointer return value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_getTxBuffer(const uint8 dmaChannel_u8, uint8** buffer_pp);

/**
 * @brief Read the pointer to the receive buffer
 * @param dmaChannel_u8 DMA channel index
 * @param buffer_pp buffer pointer return value
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_getRxBuffer(const uint8 dmaChannel_u8, uint8** buffer_pp);

/**
 * @brief Read the status register of the DMA channel
 * @param dmaChannel_u8 DMA channel index
 * @return status value
 */
uint32 Geth_Dma_getEventStatus(const uint8 dmaChannel_u8);

/**
 * @brief Clears the status register of the DMA channel
 * @param dmaChannel_u8 DMA channel index
 * @param eventsMask_u32 DMA events to be cleared
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_clrEventStatus(const uint8 dmaChannel_u8, uint32 eventsMask_u32);

/**
 * @brief Disables the interrupt events of the DMA channel
 * @param dmaChannel_u8 DMA channel index
 * @param irqEventMask_u32 DMA interrupt events to be disabled
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_disableInterrupt(const uint8 dmaChannel_u8, uint32 irqEventMask_u32);

/**
 * @brief Enables the interrupt events of the DMA channel
 * @param dmaChannel_u8 DMA channel index
 * @param irqEventMask_u32 DMA interrupt events to be enabled
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_enableInterrupt(const uint8 dmaChannel_u8, uint32 irqEventMask_u32);

/**
 * @brief Reads Rx timestamp from current receive descriptor
 * @param dmaChannel_u8 DMA channel index
 * @param timeStamp_p pointer to the timestamp struct
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_getRxTimestamp(const uint8 dmaChannel_u8, Sys_TimeStamp_t* const timeStamp_p);

/**
 * @brief Gives a certain DMA access to a DLMU memory for the given CPU
 * @param dlmuIdx_u8 DLMU index configured by SolutionDesigner
 * @param dmaChannel_u8 DMA channel index
 * @return SUCCESS or FAILURE
 */
sint32 Geth_Dma_setDlmuProt(const uint8 dlmuIdx_u8, const uint8 dmaChannel_u8);

sint32 Geth_Dma_setPacketId(const uint8 dmaChannel_u8, const uint16 packetId_u16);

sint32 Geth_Dma_enTxTimeStamp(const uint8 dmaChannel_u8);
sint32 Geth_Dma_disTxTimeStamp(const uint8 dmaChannel_u8);
sint32 Geth_Dma_setLaunchTime(const uint8 dmaChannel_u8, const uint8 slotNo_u8, const uint8 ltSeconds_u8, const uint32 ltNanoSeconds_u32);

#endif /* COMPONENTS_DMA_GETH_DMA_H_ */
