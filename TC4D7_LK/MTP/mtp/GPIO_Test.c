/**********************************************************************************************************************
 * \file TMADC_Single_Channel.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <stdio.h>
#include "IfxAdc_Tmadc.h"
#include "IfxPms_reg.h"
#include "IfxPmsEvr.h"
#include "GPIO_Test.h"
#include "mtp_application.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

#define DELAY(loop_till)       do { for( volatile uint32 loop_cnt = 0; loop_cnt < loop_till; loop_cnt++); } while(0)
#define DELAY_TIME             (1000UL)

#define LOGIC_HIGH      0xAAA                       // Logic High threshold for testing the ADC pins
#define LOGIC_LOW       0x555                       // Logic Low threshold for testing the ADC pins

#define TESTER_PIN             &MODULE_P20, 7       // TESTER_PIN is used for testing the all pins with respect to it
#define PULSE_TRAIN_LEN        500                  // Pulse Train of one's and zero's

#define NULL_ANALOG_PIN     -1, -1, 0xFF            // -1 (IfxAdc_TmadcModule_none), -1 (IfxAdc_TmadcChannel_none), 0xFF (casually taken)
#define NULL_DIGITAL_PIN    &MODULE_P20, 2          // This pin is not used in this MCU, that's why I choose this port & pin
#define TOTAL_ANALOG_PINS   16                      // Total number of Analog Pins to be tested

extern boolean Timeout;



typedef enum
{
        Digital_Pin,
        Analog_Pin
}en_Pin_Type_t;


typedef struct
{
        en_Pin_Type_t   pin_type;        /*         Pin Type       */
        uint8           pin_name[10];    /*         Pin Name       */

        Ifx_P*          g_Port;          /*                        */
        uint8           g_Pin;           /*  For the Digital Pins  */

        uint8           ADC_Module;      /*                       */
        uint8           ADC_Channel;     /*  For the Analog Pins  */
        uint8           ResultReg;       /*                       */
}stc_Test_Pins_t;


stc_Test_Pins_t Test_Pins[] =
{
        /* X1 Header (Outer side) */
        {Digital_Pin, "P20.8",  &MODULE_P20,8,  NULL_ANALOG_PIN},    // P20.8
        {Digital_Pin, "P20.10", &MODULE_P20,10, NULL_ANALOG_PIN},    // P20.10
        {Digital_Pin, "P20.12", &MODULE_P20,12, NULL_ANALOG_PIN},    // P20.12
        {Digital_Pin, "P20.14", &MODULE_P20,14, NULL_ANALOG_PIN},    // P20.14
        {Digital_Pin, "P15.5",  &MODULE_P15,5,  NULL_ANALOG_PIN},    // P15.5
        {Digital_Pin, "P20.3",  &MODULE_P20,3,  NULL_ANALOG_PIN},    // P20.3
        {Digital_Pin, "P20.0",  &MODULE_P20,0,  NULL_ANALOG_PIN},    // P20.0
        {Digital_Pin, "P21.4",  &MODULE_P21,4,  NULL_ANALOG_PIN},    // P21.4
        {Digital_Pin, "P16.12", &MODULE_P16,12, NULL_ANALOG_PIN},    // P16.12
        {Digital_Pin, "P16.11", &MODULE_P16,11, NULL_ANALOG_PIN},    // P16.11
        {Digital_Pin, "P16.10", &MODULE_P16,10, NULL_ANALOG_PIN},    // P16.10
        {Digital_Pin, "P16.9",  &MODULE_P16,9,  NULL_ANALOG_PIN},    // P16.9
        {Digital_Pin, "P23.5",  &MODULE_P23,5,  NULL_ANALOG_PIN},    // P23.5
        {Digital_Pin, "P33.14", &MODULE_P33,14, NULL_ANALOG_PIN},    // P33.14
        {Digital_Pin, "P23.1",  &MODULE_P23,1,  NULL_ANALOG_PIN},    // P23.1
        {Digital_Pin, "P33.13", &MODULE_P33,13, NULL_ANALOG_PIN},    // P33.13
        {Digital_Pin, "P33.11", &MODULE_P33,11, NULL_ANALOG_PIN},    // P33.11
        /* X1 Header (Inner side) */
        {Digital_Pin, "P20.9",  &MODULE_P20,9,   NULL_ANALOG_PIN},    // P20.9
        {Digital_Pin, "P20.11", &MODULE_P20,11,  NULL_ANALOG_PIN},    // P20.11
        {Digital_Pin, "P20.13", &MODULE_P20,13,  NULL_ANALOG_PIN},    // P20.13
        {Digital_Pin, "P15.4",  &MODULE_P15,4,   NULL_ANALOG_PIN},    // P15.4
        {Digital_Pin, "P20.1",  &MODULE_P20,1,   NULL_ANALOG_PIN},    // P20.1
        {Digital_Pin, "P21.5",  &MODULE_P21,5,   NULL_ANALOG_PIN},    // P21.5
        {Digital_Pin, "P22.1",  &MODULE_P22,1,   NULL_ANALOG_PIN},    // P22.1
        {Digital_Pin, "P22.3",  &MODULE_P22,3,   NULL_ANALOG_PIN},    // P22.3
        {Digital_Pin, "P22.2",  &MODULE_P22,2,   NULL_ANALOG_PIN},    // P22.2
        {Digital_Pin, "P22.0",  &MODULE_P22,0,   NULL_ANALOG_PIN},    // P22.0
        {Digital_Pin, "P23.4",  &MODULE_P23,4,   NULL_ANALOG_PIN},    // P23.4
        {Digital_Pin, "P32.7",  &MODULE_P32,7,   NULL_ANALOG_PIN},    // P32.7
        {Digital_Pin, "P32.6",  &MODULE_P32,6,   NULL_ANALOG_PIN},    // P32.6
        {Digital_Pin, "P32.4",  &MODULE_P32,4,   NULL_ANALOG_PIN},    // P32.4
        {Digital_Pin, "P33.12", &MODULE_P33,12,  NULL_ANALOG_PIN},    // P33.12

        /* X2 Header (Inner side) */
        {Digital_Pin, "P03.6",  &MODULE_P03,6,  NULL_ANALOG_PIN},   // P03.6
        {Digital_Pin, "P03.7",  &MODULE_P03,7,  NULL_ANALOG_PIN},   // P03.7
        {Digital_Pin, "P03.9",  &MODULE_P03,9,  NULL_ANALOG_PIN},   // P03.9
        {Digital_Pin, "P03.11", &MODULE_P03,11, NULL_ANALOG_PIN},   // P03.11
        {Digital_Pin, "P00.9",  &MODULE_P00,9,  NULL_ANALOG_PIN},   // P00.9
        {Digital_Pin, "P00.11", &MODULE_P00,11, NULL_ANALOG_PIN},   // P00.11
        {Analog_Pin,  "AN21", NULL_DIGITAL_PIN, IfxAdc_TmadcModule_1, IfxAdc_TmadcChannel_9, IfxAdc_TmadcResultReg_9},     // AN21
        {Analog_Pin,  "AN13", NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_13, IfxAdc_TmadcResultReg_13},   // AN13
        {Analog_Pin,  "AN7",  NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_7, IfxAdc_TmadcResultReg_7},     // AN7
        {Analog_Pin,  "AN5",  NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_5, IfxAdc_TmadcResultReg_5},     // AN5
        {Analog_Pin,  "AN3",  NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_3, IfxAdc_TmadcResultReg_3},     // AN3
        {Analog_Pin,  "AN1",  NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_1, IfxAdc_TmadcResultReg_1},     // AN1
        {Digital_Pin, "P33.0",  &MODULE_P33,0,  NULL_ANALOG_PIN},   // P33.0
        {Digital_Pin, "P33.2",  &MODULE_P33,2,  NULL_ANALOG_PIN},   // P33.2
        {Digital_Pin, "P33.4",  &MODULE_P33,4,  NULL_ANALOG_PIN},   // P33.4
        {Digital_Pin, "P33.6",  &MODULE_P33,6,  NULL_ANALOG_PIN},   // P33.6
        {Digital_Pin, "P33.8",  &MODULE_P33,8,  NULL_ANALOG_PIN},   // P33.8
        {Digital_Pin, "P33.10", &MODULE_P33,10, NULL_ANALOG_PIN},   // P33.10
        /* X2 Header (Outer side) */
        {Digital_Pin, "P00.0",   &MODULE_P00,0,   NULL_ANALOG_PIN},   // P00.0
        {Digital_Pin, "P00.8",   &MODULE_P00,8,   NULL_ANALOG_PIN},   // P00.8
        {Digital_Pin, "P03.10",  &MODULE_P03,10,  NULL_ANALOG_PIN},   // P03.10
        {Digital_Pin, "P00.7",   &MODULE_P00,7,   NULL_ANALOG_PIN},   // P00.7
        {Digital_Pin, "P00.10",  &MODULE_P00,10,  NULL_ANALOG_PIN},   // P00.10
        {Digital_Pin, "P00.12",  &MODULE_P00,12,  NULL_ANALOG_PIN},   // P00.12
        {Analog_Pin,  "AN20",  NULL_DIGITAL_PIN, IfxAdc_TmadcModule_1, IfxAdc_TmadcChannel_8, IfxAdc_TmadcResultReg_8},     // AN20
        {Analog_Pin,  "AN12",  NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_12, IfxAdc_TmadcResultReg_12},   // AN12
        {Analog_Pin,  "AN6",   NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_6, IfxAdc_TmadcResultReg_6},     // AN6
        {Analog_Pin,  "AN4",   NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_4, IfxAdc_TmadcResultReg_4},     // AN4
        {Analog_Pin,  "AN2",   NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_2, IfxAdc_TmadcResultReg_2},     // AN2
        {Digital_Pin, "P33.1",   &MODULE_P33,1,   NULL_ANALOG_PIN},   // P33.1
        {Digital_Pin, "P33.3",   &MODULE_P33,3,   NULL_ANALOG_PIN},   // P33.3
        {Digital_Pin, "P33.5",   &MODULE_P33,5,   NULL_ANALOG_PIN},   // P33.5
        {Digital_Pin, "P33.15",  &MODULE_P33,15,  NULL_ANALOG_PIN},   // P33.15
        {Digital_Pin, "P33.9 ",  &MODULE_P33,9,   NULL_ANALOG_PIN},   // P33.9

        /* X304 Header */
        {Digital_Pin, "P15.3",  &MODULE_P15,3, NULL_ANALOG_PIN},   // P15.3
        {Digital_Pin, "P15.2",  &MODULE_P15,2, NULL_ANALOG_PIN},   // P15.2
        {Digital_Pin, "P02.0",  &MODULE_P02,0, NULL_ANALOG_PIN},   // P02.0
        {Digital_Pin, "P02.1",  &MODULE_P02,1, NULL_ANALOG_PIN},   // P02.1
        {Digital_Pin, "P03.3",  &MODULE_P03,3, NULL_ANALOG_PIN},   // P03.3
        {Digital_Pin, "P02.3",  &MODULE_P02,3, NULL_ANALOG_PIN},   // P02.3
        {Digital_Pin, "P02.5",  &MODULE_P02,5, NULL_ANALOG_PIN},   // P02.5
        {Digital_Pin, "P02.4",  &MODULE_P02,4, NULL_ANALOG_PIN},   // P02.4

        /* X303 Header */
        {Digital_Pin, "P02.6", &MODULE_P02,6, NULL_ANALOG_PIN},   // P02.6
        {Digital_Pin, "P02.7", &MODULE_P02,7, NULL_ANALOG_PIN},   // P02.7
        {Digital_Pin, "P03.4", &MODULE_P03,4, NULL_ANALOG_PIN},   // P03.4
        {Digital_Pin, "P03.2", &MODULE_P03,2, NULL_ANALOG_PIN},   // P03.2
        {Digital_Pin, "P03.0", &MODULE_P03,0, NULL_ANALOG_PIN},   // P03.0
        {Digital_Pin, "P03.1", &MODULE_P03,1, NULL_ANALOG_PIN},   // P03.1
        {Digital_Pin, "P13.2", &MODULE_P13,2, NULL_ANALOG_PIN},   // P13.2
        {Digital_Pin, "P13.1", &MODULE_P13,1, NULL_ANALOG_PIN},   // P13.1

        /* X301 Header */
        {Digital_Pin, "P00.1", &MODULE_P00,1, NULL_ANALOG_PIN},   // P00.1
        {Digital_Pin, "P00.2", &MODULE_P00,2, NULL_ANALOG_PIN},   // P00.2
        {Digital_Pin, "P00.3", &MODULE_P00,3, NULL_ANALOG_PIN},   // P00.3
        {Digital_Pin, "P00.4", &MODULE_P00,4, NULL_ANALOG_PIN},   // P00.4
        {Digital_Pin, "P00.5", &MODULE_P00,5, NULL_ANALOG_PIN},   // P00.5
        {Digital_Pin, "P00.6", &MODULE_P00,6, NULL_ANALOG_PIN},   // P00.6

        /* Mikro BUS Header (PWM pin side) */
        {Digital_Pin, "P13.2", &MODULE_P13,2, NULL_ANALOG_PIN},   // P13.2
        {Digital_Pin, "P13.1", &MODULE_P13,1, NULL_ANALOG_PIN},   // P13.1
        {Digital_Pin, "P15.0", &MODULE_P15,0, NULL_ANALOG_PIN},   // P15.0
        {Digital_Pin, "P15.1", &MODULE_P15,1, NULL_ANALOG_PIN},   // P15.1
        {Digital_Pin, "P10.7", &MODULE_P10,7, NULL_ANALOG_PIN},   // P10.7
        {Digital_Pin, "P02.8", &MODULE_P02,8, NULL_ANALOG_PIN},   // P02.8
        /* Mikro BUS Header (AN pin side) */
        {Digital_Pin, "P15.6", &MODULE_P15,6, NULL_ANALOG_PIN},   // P15.6
        {Digital_Pin, "P15.7", &MODULE_P15,7, NULL_ANALOG_PIN},   // P15.7
        {Digital_Pin, "P15.8", &MODULE_P15,8, NULL_ANALOG_PIN},   // P15.8
        {Digital_Pin, "P14.7", &MODULE_P14,7, NULL_ANALOG_PIN},   // P14.7
        {Digital_Pin, "P10.6", &MODULE_P10,6, NULL_ANALOG_PIN},   // P10.6
        {Analog_Pin, "AN10", NULL_DIGITAL_PIN, IfxAdc_TmadcModule_0, IfxAdc_TmadcChannel_10, IfxAdc_TmadcResultReg_10},   // AN10

        /* S2G1 Pins (RX pin side) */
        {Digital_Pin, "P01.5",  &MODULE_P01,5,  NULL_ANALOG_PIN},   // P01.5
        {Digital_Pin, "P01.6",  &MODULE_P01,6,  NULL_ANALOG_PIN},   // P01.6
        {Digital_Pin, "P01.7",  &MODULE_P01,7,  NULL_ANALOG_PIN},   // P01.7
        {Digital_Pin, "P02.2",  &MODULE_P02,2,  NULL_ANALOG_PIN},   // P02.2
        {Digital_Pin, "P32.2",  &MODULE_P32,2,  NULL_ANALOG_PIN},   // P32.2
        {Digital_Pin, "P23.4",  &MODULE_P23,4,  NULL_ANALOG_PIN},   // P23.4
        {Digital_Pin, "P02.9",  &MODULE_P02,9,  NULL_ANALOG_PIN},   // P02.9
        {Digital_Pin, "P02.10", &MODULE_P02,10, NULL_ANALOG_PIN},   // P02.10
        /* S2G1 Pins (AN1 pin side) */
        {Digital_Pin, "P14.9",  &MODULE_P14,9,  NULL_ANALOG_PIN},   // P14.9
        {Digital_Pin, "P10.3",  &MODULE_P10,3,  NULL_ANALOG_PIN},   // P10.3
        {Digital_Pin, "P13.1",  &MODULE_P13,1,  NULL_ANALOG_PIN},   // P13.1
        {Digital_Pin, "P13.2",  &MODULE_P13,2,  NULL_ANALOG_PIN},   // P13.2
        //{Digital_Pin, "P40.10", &MODULE_P40,10, NULL_ANALOG_PIN},   // AN17/P40.10
        {Analog_Pin, "AN17", NULL_DIGITAL_PIN, IfxAdc_TmadcModule_1, IfxAdc_TmadcChannel_5, IfxAdc_TmadcResultReg_5},     // AN17/P40.10
        {Analog_Pin, "AN16", NULL_DIGITAL_PIN, IfxAdc_TmadcModule_1, IfxAdc_TmadcChannel_4, IfxAdc_TmadcResultReg_4},     // AN16

        /* S2G2 Pins (RX pin side) */
        {Digital_Pin, "P01.5",  &MODULE_P01,5,  NULL_ANALOG_PIN},   // P01.5
        {Digital_Pin, "P01.6",  &MODULE_P01,6,  NULL_ANALOG_PIN},   // P01.6
        {Digital_Pin, "P01.7",  &MODULE_P01,7,  NULL_ANALOG_PIN},   // P01.7
        {Digital_Pin, "P00.8",  &MODULE_P00,8,  NULL_ANALOG_PIN},   // P00.8
        {Digital_Pin, "P32.5",  &MODULE_P32,5,  NULL_ANALOG_PIN},   // P32.5
        {Digital_Pin, "P02.11", &MODULE_P02,11, NULL_ANALOG_PIN},   // P02.11
        {Digital_Pin, "P20.0",  &MODULE_P20,0,  NULL_ANALOG_PIN},   // P20.0
        {Digital_Pin, "P20.3",  &MODULE_P20,3,  NULL_ANALOG_PIN},   // P20.3
        /* S2G2 Pins (AN1 pin side) */
        {Digital_Pin, "P14.10", &MODULE_P14,10, NULL_ANALOG_PIN},   // P14.10
        {Digital_Pin, "P10.8",  &MODULE_P10,8,  NULL_ANALOG_PIN},   // P10.8
        {Digital_Pin, "P13.1",  &MODULE_P13,1,  NULL_ANALOG_PIN},   // P13.1
        {Digital_Pin, "P13.2",  &MODULE_P13,2,  NULL_ANALOG_PIN},   // P13.2
        //{Digital_Pin, "P40.12", &MODULE_P40,12, NULL_ANALOG_PIN},   // AN19/P40.12
        {Analog_Pin, "AN19", NULL_DIGITAL_PIN, IfxAdc_TmadcModule_1, IfxAdc_TmadcChannel_7, IfxAdc_TmadcResultReg_7},     // AN19/P40.12
        //{Digital_Pin, "P40.11", &MODULE_P40,11, NULL_ANALOG_PIN}    // AN18/P40.11
        {Analog_Pin, "AN18", NULL_DIGITAL_PIN, IfxAdc_TmadcModule_1, IfxAdc_TmadcChannel_6, IfxAdc_TmadcResultReg_6},     // AN18/P40.11

};


#define TOTAL_TEST_PINS     (sizeof(Test_Pins)/sizeof(Test_Pins[0]))

IfxAdc_Tmadc g_tmadc[TOTAL_ANALOG_PINS];                                        /* TMADC module handle                                  */
IfxAdc_Tmadc_Ch g_tmadcChannel[TOTAL_ANALOG_PINS];                              /* TMADC channel handle                                 */
IfxAdc_Tmadc_Config g_tmadcConfig[TOTAL_ANALOG_PINS];                           /* TMADC configuration structure                        */
IfxAdc_Tmadc_ChConfig g_tmadcChannel0Config[TOTAL_ANALOG_PINS];                 /* TMADC channel configuration structure                */
volatile uint16  g_result[TOTAL_ANALOG_PINS];                                   /* Variable to store the result of the measurement      */
volatile uint8 test_pin_idx=0;                                                  // For tracing the pins



/* Function to initialize and run the TMADC */
void initTMADC(uint8 pin_idx)
{
    /* Initialize the TMADC module */
    initTMADCModule(pin_idx);

    /* Initialize the channel */
    initTMADCChannel(pin_idx);

    /* Run the TMADC module */
    //IfxAdc_Tmadc_runModule(&g_tmadc[i]);
}

/* Function to initialize the TMADC module */
void initTMADCModule(uint8 pin_idx)
{
    /* Enable ADC module */
    IfxAdc_enableModule(&MODULE_ADC);

    /* Initialize module to default */
    IfxAdc_Tmadc_initModuleConfig(&g_tmadcConfig[pin_idx], &MODULE_ADC);

    /* Change TMADC configuration */
    g_tmadcConfig[pin_idx].id                = Test_Pins[test_pin_idx].ADC_Module;                       /* Module ID                                 */
    g_tmadcConfig[pin_idx].calEnable         = 1;                                /* Calibration enabled                       */

    /* Initialize TMADC module with updated configuration */
    IfxAdc_Tmadc_initModule(&g_tmadc[pin_idx], &g_tmadcConfig[pin_idx]);
}

/* Function to initialize the TMADC channel */
void initTMADCChannel(uint8 pin_idx)
{
    /* Initialize the configuration with default values */
    IfxAdc_Tmadc_initChannelConfig(&g_tmadcChannel0Config[pin_idx], &MODULE_ADC);

    /* Change TMADC channel configuration */
    /* Select the channel ID and the respective result register */
    g_tmadcChannel0Config[pin_idx].id             = Test_Pins[test_pin_idx].ADC_Channel;                    /* Channel ID                             */
    g_tmadcChannel0Config[pin_idx].moduleId       = Test_Pins[test_pin_idx].ADC_Module;                     /* Select TMADC module                    */
    g_tmadcChannel0Config[pin_idx].samplingTimeNS = 100;                            /* Set sampling time period               */
    g_tmadcChannel0Config[pin_idx].mode           = IfxAdc_TmadcOpMode_continuous;  /* Select operating mode - continuous     */
    g_tmadcChannel0Config[pin_idx].core           = IfxAdc_TmadcSarCore_0;          /* Select TMADC SAR core                  */

    g_tmadcChannel0Config[pin_idx].resultCfg.resultReg   = Test_Pins[test_pin_idx].ResultReg; /* Configure result register              */
    g_tmadcChannel0Config[pin_idx].resultCfg.waitForRead = 1;                       /* Enable wait-for-read mode              */

    /* Initialize the channel */
    IfxAdc_Tmadc_initChannel(&g_tmadcChannel[pin_idx], &g_tmadcChannel0Config[pin_idx]);

#ifdef ADC_PORT_PIN
    IfxPort_setPinMode(ADC_PORT_PIN, IfxPort_Mode_inputNoPullDevice);
#endif

}


void Verify_PinHigh(uint8 pin_idx)
{

    if(Test_Pins[test_pin_idx].pin_type == Digital_Pin)
    {
        uint8 g_Result = 0;

        while((g_Result == 0) && (!Timeout))                                // wait until detect HIGH
            g_Result = IfxPort_getPinState(TESTER_PIN);
    }

    else if(Test_Pins[test_pin_idx].pin_type == Analog_Pin)
    {
        g_result[pin_idx] = 0x0000;
        while((g_result[pin_idx] < LOGIC_LOW) && (!Timeout))                // wait until detect HIGH
            g_result[pin_idx] = IfxAdc_Tmadc_readChannelResult(&g_tmadcChannel[pin_idx]);
    }

}


void Verify_PinLow(uint8 pin_idx)
{

    if(Test_Pins[test_pin_idx].pin_type == Digital_Pin)
    {
        uint8 g_Result = 1;

        while((g_Result == 1) && (!Timeout))                                // wait until detect LOW
            g_Result = IfxPort_getPinState(TESTER_PIN);
    }

    else if(Test_Pins[test_pin_idx].pin_type == Analog_Pin)
    {
        g_result[pin_idx] = 0xFFFF;
        while((g_result[pin_idx] > LOGIC_HIGH) && (!Timeout))               // wait until detect LOW
            g_result[pin_idx] = IfxAdc_Tmadc_readChannelResult(&g_tmadcChannel[pin_idx]);
    }

}


void Verify_Pin(uint8 pin_idx)
{
    uint16 bits = PULSE_TRAIN_LEN;

    printf("ins: Test the %s pin\n", Test_Pins[test_pin_idx].pin_name);

    if(Test_Pins[test_pin_idx].pin_type == Digital_Pin)
    {
        /* If the pin is a digital pin, then the "TESTER_PIN" pin sets as INPUT pin */
        IfxPort_setPinMode(TESTER_PIN, IfxPort_Mode_inputPullUp);

        Ifx_P*  port = Test_Pins[test_pin_idx].g_Port;
        uint8   pin  = Test_Pins[test_pin_idx].g_Pin;

        Start_Timer(10);                        // Start the Timer with 10 second limit

        while(bits>0)
        {
            IfxPort_setPinLow(port, pin);       // make the test pin LOW
            Verify_PinLow(0);                   // verify LOW by the TESTER_PIN
            DELAY(DELAY_TIME);

            IfxPort_setPinHigh(port, pin);      // make the test pin HIGH
            Verify_PinHigh(0);                  // verify HIGH by the TESTER_PIN
            DELAY(DELAY_TIME);

            bits--;

            if(Timeout)
                break;
        }

            IfxPort_setPinHigh(port, pin);
            Stop_Timer();                       // stop the timer
    }

    else if(Test_Pins[test_pin_idx].pin_type == Analog_Pin)
    {
        /* If the pin is a digital pin, then the "TESTER_PIN" pin sets as OUTPUT pin */
        IfxPort_setPinModeOutput(TESTER_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
        IfxPort_setPinHigh(TESTER_PIN);

        Start_Timer(10);                        // Start the Timer with 10 second limit

        while(bits>0)
        {
            IfxPort_setPinLow(TESTER_PIN);      // make the TESTER_PIN LOW
            Verify_PinLow(pin_idx);             // verify LOW by the testing analog pin
            DELAY(DELAY_TIME);

            IfxPort_setPinHigh(TESTER_PIN);     // make the TESTER_PIN HIGH
            Verify_PinHigh(pin_idx);            // verify HIGH by the testing analog pin
            DELAY(DELAY_TIME);

            bits--;

            if(Timeout)
                break;
        }

            IfxPort_setPinHigh(TESTER_PIN);
            Stop_Timer();                       // stop the timer
    }


    if((bits == 0) && (!Timeout))
    {
        printf("ins:%s pin is working \n", Test_Pins[test_pin_idx].pin_name);
    }
    else
    {
        printf("ins:%s is not working \n", Test_Pins[test_pin_idx].pin_name);
    }

}


boolean Pin_Test(void)
{
    volatile uint8 analog_pin_idx;          // For tracing the analog pins

    Port16_special_configuration();         // Port16 is an special types of port, that's there are some special configuration


    analog_pin_idx = 0;

    // Initialize the Analog and Digital pins
    for(test_pin_idx=0; test_pin_idx<TOTAL_TEST_PINS; test_pin_idx++)
    {

        if(Test_Pins[test_pin_idx].pin_type == Digital_Pin)
        {
            /* If the pin is a digital pin, then the "test pin" set as OUTPUT and the "TESTER_PIN" pin sets as INPUT pin */
            Ifx_P*  port = Test_Pins[test_pin_idx].g_Port;
            uint8   pin  = Test_Pins[test_pin_idx].g_Pin;

            IfxPort_setPinModeOutput(port, pin, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
            IfxPort_setPinHigh(port, pin);
        }

        else if(Test_Pins[test_pin_idx].pin_type == Analog_Pin)
        {
            /* If the pin is an analog pin, then the "test pin" set as analog INPUT and the "TESTER_PIN" pin sets as OUTPUT pin */
            initTMADC(analog_pin_idx);
            analog_pin_idx++;
        }

    }


    for(volatile uint8 analog_pin_idx=0; analog_pin_idx<TOTAL_ANALOG_PINS; analog_pin_idx++)
    {
        // Run the TMADC modules for the analog pins
        IfxAdc_Tmadc_runModule(&g_tmadc[analog_pin_idx]);
        DELAY(DELAY_TIME);
    }



    analog_pin_idx = 0;

    // Verify the analog and digital pins
    for(test_pin_idx=0; test_pin_idx<TOTAL_TEST_PINS; test_pin_idx++)
    {

        if(Test_Pins[test_pin_idx].pin_type == Digital_Pin)
        {
            Verify_Pin(0);
            if(Timeout) return TRUE;
        }

        else if(Test_Pins[test_pin_idx].pin_type == Analog_Pin)
        {
            Verify_Pin(analog_pin_idx);
            analog_pin_idx++;
            if(Timeout) return TRUE;
        }
    }

    return TRUE;

}


void Port16_special_configuration(void)
{
    // Power the port16
    IfxPmsEvr_enableVoltageRail(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif);

    IfxPort_resetPinControllerSelection(&MODULE_P16,12);        // reset the pin for the use of GPIO
    IfxPort_resetPinControllerSelection(&MODULE_P16,11);        // reset the pin for the use of GPIO
    IfxPort_resetPinControllerSelection(&MODULE_P16,10);        // reset the pin for the use of GPIO
    IfxPort_resetPinControllerSelection(&MODULE_P16,9);         // reset the pin for the use of GPIO
}



