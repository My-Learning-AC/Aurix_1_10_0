/**
 * \file board.c
 * \brief Functions to interface the board specific peripherals
 *
 * \version see header file
 * \copyright Copyright (c) 2019-2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include <stdio.h>

#include "IfxPort_PinMap.h"
#include "IfxAsclin_PinMap.h"
#include "Ifx_reg.h"
#include "board.h"
#include "stm.h"
#include "serialio.h"

uint32 g_Board_TickCount1ms_u32;
volatile boolean g_Board_initDone_b = FALSE;

/******************************************************
** Ethernet *******************************************
*******************************************************/
#ifdef CONFIG_BOARD_GETH_ENABLE
    #include "geth_mdio.h"
    #include "geth_mac.h"
    #include "geth_brdg.h"
    #include "geth_dma.h"
    #include "geth_prot.h"
    #include "hsphy.h"
    #include "eth_mii.h"
#endif

#ifdef CONFIG_DUT_BOARD
#include "dp83825i.h"

#define ETH_NO_OF_PHYS (1u)
ETH_PHY_t DP83825I_0 =
{
    .ethType = ETH_TYPE_GETH,
    .peripheryIdx_u8 = 0,
    .hsphyPort_u8 = 0,
    .phyAddr_u8 = 0,
    .mdioPort_u8 = 0,
    .mdioType = ETH_TYPE_GETH,
    .macPort_u8 = 0,
    .phyClause45_u8 = 0,
    .ethPhyFunc.mdio_write = geth0_mdio_write_cl22,
    .ethPhyFunc.mdio_read = geth0_mdio_read_cl22,
    .ethPhyFunc.mdio_write_c45 = geth0_mdio_write_cl45,
    .ethPhyFunc.mdio_read_c45 = geth0_mdio_read_cl45,
    .ethPhyFunc.phy_init = Dp83825i_init,
    .ethPhyFunc.phy_ethLinkUp = Dp83825i_linkup,
    .gethPhyIo.ethPhyInterface = ETH_PHY_INTERFACE_RMII,
    .gethPhyIo.MDIO.mdc   = &IfxGeth0_P0_MDC_P21_2_OUT,
    .gethPhyIo.MDIO.mdio  = &IfxGeth0_PX_MDIO_P21_3_INOUT,
    .gethPhyIo.RMII.crsdv  = &IfxGeth0_P0_CRSDVC_P16_1_IN,
    .gethPhyIo.RMII.rxd0  = &IfxGeth0_P0_RXD0D_P16_4_IN,
    .gethPhyIo.RMII.rxd1  = &IfxGeth0_P0_RXD1D_P16_0_IN,
    .gethPhyIo.RMII.txen  = &IfxGeth0_P0_RMIIC_TXEN_P16_13_OUT,
    .gethPhyIo.RMII.txd0  = &IfxGeth0_P0_RMIIC_TXD0_P16_6_OUT,
    .gethPhyIo.RMII.txd1  = &IfxGeth0_P0_RMIIC_TXD1_P16_8_OUT,
    .gethPhyIo.RMII.refclk = &IfxGeth0_P0_REFCLKD_P16_2_IN
};

#if (GETH_PORT0_EN == 1)
    ETH_PHY_t *ethPhy0_p = &DP83825I_0;
#endif
#endif


/******************************************************
** LED ************************************************
*******************************************************/
#if defined(CONFIG_BOARD_LED_ENABLE)
const LED_t LED_0 =
{
  .pin = &IfxPort_P03_9,
  .type = LED_TYPE_ACTIVE_LOW
};

const LED_t LED_1 =
{
  .pin = &IfxPort_P03_10,
  .type = LED_TYPE_ACTIVE_LOW
};
#endif /* CONFIG_BOARD_LED_ENABLE */

/******************************************************
** Serial IO ******************************************
*******************************************************/
#if defined(CONFIG_BOARD_SERIALIO_ENABLE)
SERIALIO_t SERIALIO =
{
  .asclin = &MODULE_ASCLIN0,
  .tx_pin = &IfxAsclin0_TX_F_P14_0_OUT,
  .rx_pin = &IfxAsclin0_RXA_F_P14_1_IN
};
#endif /* CONFIG_BOARD_SERIALIO_ENABLE */


/******************************************************
** On-board Periphery Init ****************************
*******************************************************/
void Board_setupPMS(void)
{
    MODULE_PMS.VMONP.VDDHSIFCON.U = 0x1A3A4A31;
    MODULE_PMS.VMONP.VDDPHY0CON.U = 0x1EF84D97;
    MODULE_PMS.VMONP.VDDPHY1CON.U = 0x1EF84D97;
    MODULE_PMS.VMONP.VDDPHY2CON.U = 0x1EF84D97;
    MODULE_PMS.VMONP.VDDPHPHY0CON.U = 0x15944A31;
    MODULE_PMS.VMONP.VDDPHPHY1CON.U = 0x15944A31;

    MODULE_PMS.VMONP.VDDHSIFRST.U = 0x2F868001;
    MODULE_PMS.VMONP.VDDPHY0RST.U = 0x2F8F0001;
    MODULE_PMS.VMONP.VDDPHY1RST.U = 0x2F8F0001;
    MODULE_PMS.VMONP.VDDPHY2RST.U = 0x2F8F0001;
    MODULE_PMS.VMONP.VDDPHPHY0RST.U = 0x2D850001;
    MODULE_PMS.VMONP.VDDPHPHY1RST.U = 0x2D850001;
    MODULE_PMS.VMONP.VDDPHPHY2RST.U = 0x2D850001;
}

#define PAYLOAD_SIZE (512)
static IFX_ALIGN(4) EthernetHeader *pFrame;


sint32 litekitInit(const uint32 moduleToInit_u32)
{
    if ((moduleToInit_u32 & BOARD_LED_INIT) != 0)
    {
        //LED_Init(&LED_0);
        //LED_Init(&LED_1);
    }
    if ((moduleToInit_u32 & BOARD_STM_INIT) != 0) STM0_Init();
    if ((moduleToInit_u32 & BOARD_SERIALIO_INIT) != 0) SERIALIO_Init(9600);
    Board_setupPMS();
    if (Geth_Init_Phase1(&MODULE_GETH0, moduleToInit_u32) == FAILURE) return FAILURE;
    if (Geth_Init_Phy(moduleToInit_u32) == FAILURE) return FAILURE;
    if (ethPhy0_p != NULL)
    {
        printf("GETH DMA Initialization ");
        if (Geth_Dma_Init(0xFFFFFF) == SUCCESS) printf(" - SUCCESS"EOL);
        else
        {
            printf(" - FAIL"EOL);
            return FAILURE;
        }

        uint16 linkSpeed = 100; //now hard-coded need to get the data from PHY later.
        if (Geth_Init_Phase2(moduleToInit_u32, linkSpeed) == FAILURE) return FAILURE;
        printf("GETH Bridge Initialization ");
        if (Geth_Bridge_Init(&MODULE_GETH0) == SUCCESS) printf(" - SUCCESS"EOL);
        else
        {
            printf(" - FAIL"EOL);
            return FAILURE;
        }
    }
    g_Board_initDone_b = TRUE;
    Geth_Mac_enableTransmitReceive(GETH_MAC0);
    Geth_Dma_Start(GETH_DMA_CHANNEL0);
#if (GETH_DMA_CH0_EN == 1)
    //Prepare the Ethernet frame
    Geth_Dma_getTxBuffer(GETH_DMA_CHANNEL0, (uint8**)&pFrame);
    memcpy(&pFrame->DestMAC[0], &g_gethBroadCast_a[0], 6);
    memcpy(&pFrame->SrcMAC[0], &GETH_MAC0_ADDR[0], 6);
    pFrame->EtherType = big_endian16(0x22F0);
    strcpy((char*) &pFrame->Payload[0], "Hello from AURIX TC4D7 Lite Kit from GETH Port0 at 100Mbps");
#endif
    return SUCCESS;
}

void litekitSend(void){
     for(uint32 i = 0; i < 20000; i++);
     Geth_Dma_transmitBuffer(GETH_DMA_CHANNEL0, (uint8 *)&pFrame[0], PAYLOAD_SIZE);
}

void Board_SysTick_Callback(void)
{
    g_Board_TickCount1ms_u32++;
}

