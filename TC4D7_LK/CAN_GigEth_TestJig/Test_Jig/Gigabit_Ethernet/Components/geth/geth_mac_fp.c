/**
 * \file geth_mac_fp.c
 * \brief Functions to interface to the Geth MAC Flexible Receive Parser
 *
 * \version see header file
 * \copyright Copyright (c) 2019-2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#include "geth_mac_fp.h"

sint32 Geth_FrameParser_Init(Ifx_GETH *const gethInstance_p, const uint8 gethPort_u8)
{
    if ((gethInstance_p == NULL) || (gethPort_u8 >= 2u))
    {
      return FALSE;
    }

    gethInstance_p->PORT[gethPort_u8].MTL.OPERATION_MODE.B.FRPE = 0;



    gethInstance_p->PORT[gethPort_u8].MTL.OPERATION_MODE.B.FRPE = 1;

    return TRUE;
}

sint32 Geth_FrameParser_readDword(Ifx_GETH *const gethInstance_p, const uint8 gethPort_u8, const uint16 addr_u16, uint32 *value_p)
{
    Ifx_GETH_PORT_MTL_INDIRECT_ACC_CONTROL_STATUS ctrl_sts;

    if ((gethInstance_p == NULL) || (gethPort_u8 >= 2u) || (addr_u16 > 1023) || (value_p == NULL))
    {
      return FALSE;
    }

    ctrl_sts.B.ACCSEL  = 0; /* ACC_IT: Access FRP Instruction Table */
    ctrl_sts.B.ADDR    = addr_u16; /* FRP instruction table address */
    ctrl_sts.B.WRRDN   = 0; /* Write/Read Control: 0 = Read, 1 = Write */
    ctrl_sts.B.CRWSEL  = 0; /* Continuous Read/Write Mode Select: 0 = continuous read, 1 = continuous write */
    ctrl_sts.B.CRWEN   = 0; /* Continuous Read/Write Mode enable */
    ctrl_sts.B.RXPEIEE = 0; /* ECC Inject Error Enable: 0 = disabled, 1 = enabled */
    ctrl_sts.B.STARTBUSY = 1;

    while (gethInstance_p->PORT[gethPort_u8].MTL.INDIRECT_ACC_CONTROL_STATUS.B.STARTBUSY == 1) {}

    gethInstance_p->PORT[gethPort_u8].MTL.INDIRECT_ACC_CONTROL_STATUS.U = ctrl_sts.U;

    *value_p = gethInstance_p->PORT[gethPort_u8].MTL.INDIRECT_ACC_DATA.U;

    return TRUE;
}

sint32 Geth_FrameParser_writeDword(Ifx_GETH *const gethInstance_p, const uint8 gethPort_u8, const uint16 addr_u16, uint32 value_u32)
{
    Ifx_GETH_PORT_MTL_INDIRECT_ACC_CONTROL_STATUS ctrl_sts;

    if ((gethInstance_p == NULL) || (gethPort_u8 >= 2u) || (addr_u16 > 1023))
    {
      return FALSE;
    }

    ctrl_sts.B.ACCSEL  = 0; /* ACC_IT: Access FRP Instruction Table */
    ctrl_sts.B.ADDR    = addr_u16; /* FRP instruction table address */
    ctrl_sts.B.WRRDN   = 1; /* Write/Read Control: 0 = Read, 1 = Write */
    ctrl_sts.B.CRWSEL  = 0; /* Continuous Read/Write Mode Select: 0 = continuous read, 1 = continuous write */
    ctrl_sts.B.CRWEN   = 0; /* Continuous Read/Write Mode enable */
    ctrl_sts.B.RXPEIEE = 0; /* ECC Inject Error Enable: 0 = disabled, 1 = enabled */
    ctrl_sts.B.STARTBUSY = 1;

    while (gethInstance_p->PORT[gethPort_u8].MTL.INDIRECT_ACC_CONTROL_STATUS.B.STARTBUSY == 1) {}

    gethInstance_p->PORT[gethPort_u8].MTL.INDIRECT_ACC_DATA.U = value_u32;
    gethInstance_p->PORT[gethPort_u8].MTL.INDIRECT_ACC_CONTROL_STATUS.U = ctrl_sts.U;

    while (gethInstance_p->PORT[gethPort_u8].MTL.INDIRECT_ACC_CONTROL_STATUS.B.STARTBUSY == 1) {}

    return TRUE;
}

sint32 Geth_FrameParser_readEntry(Ifx_GETH *const gethInstance_p, const uint8 gethPort_u8, const uint8 entryIdx_u8, GethMacFrameParser *entryLine_p)
{
    if ((gethInstance_p == NULL) || (gethPort_u8 >= 2u) || (entryLine_p == NULL))
    {
      return FALSE;
    }

    if (Geth_FrameParser_readDword(gethInstance_p, gethPort_u8, entryIdx_u8 * 4, &entryLine_p->row0.MD) == FALSE)
    {
        return FALSE;
    }

    if (Geth_FrameParser_readDword(gethInstance_p, gethPort_u8, entryIdx_u8 * 4 + 1, &entryLine_p->row1.ME) == FALSE)
    {
        return FALSE;
    }

    if (Geth_FrameParser_readDword(gethInstance_p, gethPort_u8, entryIdx_u8 * 4 + 2, &entryLine_p->row2.U) == FALSE)
    {
        return FALSE;
    }

    if (Geth_FrameParser_readDword(gethInstance_p, gethPort_u8, entryIdx_u8 * 4 + 3, &entryLine_p->row3.U) == FALSE)
    {
        return FALSE;
    }

    return TRUE;
}

sint32 Geth_FrameParser_writeEntry(Ifx_GETH *const gethInstance_p, const uint8 gethPort_u8, const uint8 entryIdx_u8, GethMacFrameParser *entryLine_p)
{
    if ((gethInstance_p == NULL) || (gethPort_u8 >= 2u) || (entryLine_p == NULL))
    {
      return FALSE;
    }

    if (Geth_FrameParser_writeDword(gethInstance_p, gethPort_u8, entryIdx_u8 * 4, entryLine_p->row0.MD) == FALSE)
    {
        return FALSE;
    }

    if (Geth_FrameParser_writeDword(gethInstance_p, gethPort_u8, entryIdx_u8 * 4 + 1, entryLine_p->row1.ME) == FALSE)
    {
        return FALSE;
    }

    if (Geth_FrameParser_writeDword(gethInstance_p, gethPort_u8, entryIdx_u8 * 4 + 2, entryLine_p->row2.U) == FALSE)
    {
        return FALSE;
    }

    if (Geth_FrameParser_writeDword(gethInstance_p, gethPort_u8, entryIdx_u8 * 4 + 3, entryLine_p->row3.U) == FALSE)
    {
        return FALSE;
    }

    return TRUE;
}
